\chapter{Metalinguistic Abstraction}

\section{The Metacircular Evaluator}

\subsection{The Core of the Evaluator}

\begin{exe}[4.1]
    We can put the value to evaluate first inside a \vscm{let} expression. Since 
    the \vscm{let} is transformed into a \vscm{lambda} internally, we know that 
    its argument will be evaluated before the body of the \vscm{let}.
    \scm{ch4/4.01.scm}
\end{exe}

\subsection{Representing Expressions}

\begin{exe}[4.2]
    \ \vspace{-20pt}
    \begin{itemize}
	\item[a.] The test to determine whether an expression is a procedure 
	    just checks whether it is a pair, so it will return true for all 
	    list expressions: \vscm{if}, \vscm{cond}, \vscm{begin}, 
	    \vscm{define}, \vscm{set!}, etc., and the evaluator will try to 
	    apply the procedure \vscm{if}, \vscm{cond}, etc. to the rest of the 
	    arguments. It’s not possible to transform the special forms into 
	    procedures because all the arguments of a procedure are evaluated 
	    before evaluation.
	\item[b.] The only required change to \vscm{eval} is to put the 
	    \vscm{application?} test first. Then we only need changing the 
	    definition of the \vscm{application?} predicate and the associated 
	    selectors so they reflect the new syntax.
	    \scm{ch4/4.02.scm}
    \end{itemize}
\end{exe}

\begin{exe}[4.3]
    As in exercise \ref{2.73}, a few cases can’t be assimilated to the 
    data-directed dispatch because they correspond to untagged data: here it’s 
    the case of \vscm{variable?}, \vscm{self-evaluating?} and 
    \vscm{application?}. If we had kept Louis’ idea from the previous exercise 
    to start procedure applications with \vscm{call}, \vscm{application?} could 
    have been assimilated into the dispatch. Since we don’t keep this idea, we 
    have to redefine the \vscm{application?} predicate: if we keep it as 
    \vscm{pair?} we can’t put it before the dispatch because all the special 
    forms will be considered as procedure applications, and we can’t put it 
    after the dispatch either because the procedure won’t be found in the table 
    and it will cause an error. So I consider that every expression for which no 
    procedure of the correct type is found in the table is a procedure 
    application. I used a two-dimensional table as in chapter 2, though 
    a one-dimensional table would be enough if we don’t do any other dispatch on 
    the expressions’ type.
    \scm{ch4/4.03.scm}
\end{exe}

\begin{exe}[4.4]
    If we define specific evaluation procedures \vscm{eval-and} and 
    \vscm{eval-or}, we have to add the following two lines to the definition of 
    \vscm{eval}
    \scm{ch4/4.04a.scm}
    Then we can implement the predicates, selectors and the evaluation 
    procedures in the following way:
    \scm{ch4/4.04b.scm}
    If \vscm{and} and {or} are implemented as derived expressions, the 
    predicates and selectors don’t change, but the lines regarding \vscm{and} 
    and \vscm{or} in \vscm{eval} are replaced by:
    \scm{ch4/4.04c.scm}
    And the procedures transforming \vscm{and} and \vscm{or} expressions into 
    \vscm{if} expressions can be defined as:
    \scm{ch4/4.04d.scm}
\end{exe}

\begin{exe}[4.5]
    We only need to add the appropriate predicate and selectors for this type of 
    clause so that the appropriate action is taken if the predicate evaluates to 
    a true value.
    \scm{ch4/4.05.scm}
\end{exe}

\begin{exe}[4.6]
    The only necessary modification to \vscm{eval} is to add the line:
    \scm{ch4/4.06b.scm}
    Then we can define the appropriate predicate and selectors and the 
    transformation procedure \vscm{let->combination} in the following way:
    \scm{ch4/4.06.scm}
\end{exe}

\begin{exe}[4.7]
    A \vscm{let*} expression can be rewritten as a set of nested \vscm{let} 
    expressions defining only one binding at a time, so that the second binding 
    is defined in the body of the first \vscm{let} etc. For instance, the 
    example from the book becomes:
    \scm{ch4/4.07b.scm}
    If we have already implemented \vscm{let}, it is sufficient to rewrite 
    \vscm{let*} expressions in terms of \vscm{let} expressions to handle them. 
    This can be done in the following way:
    \scm{ch4/4.07.scm}
\end{exe}

\begin{exe}[4.8]
    To support named \vscm{let}, we modify the selectors for \vscm{let} so they 
    handle both named \vscm{let}s and ordinary \vscm{let}s, and 
    \vscm{let->combination} so the generated code creates a procedure with the 
    given name instead of a lambda.
    \scm{ch4/4.08.scm}
\end{exe}

\begin{exe}[4.9]
    \label{4.9}
    I chose to implement three iterative control structures: a \vscm{while} 
    loop, an \vscm{until} loop, and a \vscm{for} loop. The return value of all 
    the expressions described is \vscm{false}, so they are useful only for their 
    side effects. The \vscm{until} and the \vscm{for} constructs are derived 
    from \vscm{while}.
    \begin{itemize}
        \item[\emph{while}] The syntax of the \vscm{while} loop is
            \vscm{(while <predicate> <body>)}. The predicate must consist of 
            a single expression. The body can consist of several expressions. 
            The body is executed while the predicate is true. If the predicate 
            is false from the beginning, the body is never evaluated.

            For instance, the evaluation of the following code prints the 
            numbers from 0 to 5 inclusive, each on a new line:
            \begin{cscm}
                (define x 0)
                (while (<= x 5)
                    (display x)
                    (newline)
                    (set! x (+ x 1)))
            \end{cscm}
            The transformation procedure for \vscm{while} expressions turns them 
            into the definition of a recursive procedure that uses the predicate 
            to decide whether to execude the body of the \vscm{while} or not, 
            followed by a call to this procedure. The procedure name is 
            generated by \vscm{gensym}, so it does not conflict with other names 
            in the program, and if two \vscm{while} are evaluated in the same 
            environment, the generated procedures will have different names.
            \scm{ch4/4.09while.scm}
        \item[\emph{until}] The syntax of the \vscm{until} loop is
            \vscm{(until <predicate> <body>)}, and such an expression is 
            equivalent to \vscm{(while (not <predicate>) <body>)}. For instance, 
            the following code prints the numbers from 0 to 4 inclusive, each on 
            a new line:
            \begin{cscm}
                (define x 0)
                (until (= x 5)
                    (display x)
                    (newline)
                    (set! x (+ x 1)))
            \end{cscm}
            \vscm{Until} expressions are easily derived from \vscm{while} 
            expressions in the following way:
            \scm{ch4/4.09until.scm}
        \item[\emph{for}] The general syntax of the \vscm{for} loop is
            \vscm{(for (<var> <start> <end-test> [<inc-exp>]) <body>)}. The body 
            can consist of several expressions. The other parts are:
            \begin{itemize}
                \item \vscm{<var>}: the name of the variable whose value is 
                    bound by the \vscm{for} loop.
                \item \vscm{<start>}: an expression giving the initial value of 
                    the variable.
                \item \vscm{<end-test>} can be either:
                    \begin{itemize}
                        \item an expression where \vscm{<var>} appears as a free 
                            variable, for instance \vscm{(< <var> 3)}. The body 
                            of the \vscm{for} is evaluated as long as the 
                            evaluation of this expression with the current value 
                            of \vscm{<var>} returns \vscm{true}.
                        \item an expression not depending on the variable bound 
                            by the \vscm{for}, whose evaluation must return 
                            a number. This is equivalent to either
                            \vscm{(<= <var> <end-test>)} or
                            \vscm{(>= <var> <end-test>)}, depending on whether 
                            the returned value is greater or smaller than the 
                            initial value.
                    \end{itemize}
                \item \vscm{<inc-exp>} can be either:
                    \begin{itemize}
                        \item an expression where \vscm{<var>} appears as a free 
                            variable, for instance \vscm{(+ <var> 2)}. It is 
                            evaluated to update the value of \vscm{<var>} before 
                            evaluating (or not) the body of the \vscm{for} 
                            again.
                        \item an expression not depending on the variable bound 
                            by the \vscm{for}, whose evaluation must return 
                            a number. This is equivalent to specifying
                            \vscm{(+ <var> <inc-exp>)}.
                        \item empty, in which case it will be assumed to be 1.
                    \end{itemize}
            \end{itemize}
            For instance, the following expressions all print the numbers from 
            0 to 5:
            \begin{cscm}
                (for (x 1 (<= x 5) (+ x 1)) (display x) (newline))

                (for (x 1 (<= x 5) 1) (display x) (newline))

                (for (x 1 (<= x 5)) (display x) (newline))

                (for (x 1 5 (+ x 1)) (display x) (newline))

                (for (x 1 5 1) (display x) (newline))

                (for (x 1 5) (display x) (newline))
            \end{cscm}
            Using a step other than one, we can print 1, .8, .6, .4, .2 and 
            0 with:
            \begin{cscm}
                (for (x 1 -.1 -.2)
                    (display x) (newline))
            \end{cscm}
            With an update function that is not simply an addition or 
            subtraction, the following prints 16, 8, 4, 2 and 1.
            \begin{cscm}
                (for (x 16 1 (/ x 2))
                    (display x) (newline))
            \end{cscm}
            It’s possible to use nested \vscm{for}s, for instance:
            \begin{cscm}
            (for (x 0 5)
                (for (y (+ x 1) (+ x 2))
                    (display x)
                    (display ", ")
                    (display y)
                    (newline)))
            \end{cscm}
            The output is:
            \begin{cscm}
                0, 1
                0, 2
                1, 2
                1, 3
                2, 3
                2, 4
                3, 4
                3, 5
                4, 5
                4, 6
                5, 6
                5, 7
            \end{cscm}
    \end{itemize}
    The implementation is more complex than that of \vscm{while}, because 
    several cases have to be considered. I had to write a procedure that checks 
    whether a given variable appears as a free variable in a given expression. 
    Then the different cases have to be considered when constructing the 
    predicate that tests whether to interrupt the loop or not, and the procedure 
    that updates the value of the variable. The \vscm{for} expression is then 
    transformed in a \vscm{let} expression containing a \vscm{while}.
    \scm{ch4/4.09for.scm}
\end{exe}

\begin{exe}[4.10]
    It’s easy to modify the symbol used as the \vscm{car} of an expression to 
    define its type: we only need changing the predicate (and the associated 
    constructor if any was defined) for this type of expression. For instance, 
    we can replace \vscm{cond} with \vscm{case}, \vscm{and} with \vscm{&&}, and 
    \vscm{or} with \vscm{||} with the following code:
    \scm{ch4/4.10a.scm}

    We can replace \vscm{not} with \vscm{!} by replacing
    \vscm{(list 'not not)} with \vscm{(list '! not)} in the list of primitive 
    procedures and redefining the \vscm{make-not} procedure defined in exercise 
    \ref{4.9}:
    \scm{ch4/4.10b.scm}

    I also modified the selectors for procedure application so that
    \vscm{(proc args)} becomes \vscm{(proc (args))}. This change actually makes 
    the syntax more complex since e.g. \vscm{(not (> x 3))} has to be written 
    \vscm{(! ((> (x 3))))}, it’s just for the sake of the example.
    \scm{ch4/4.10c.scm}

    I think that more dramatic changes such as replacing the parentheses with 
    brackets would require a lot of work since currently we rely on the 
    underlying Scheme for list processing.
\end{exe}

\subsection{Evaluator Data Structures}

\begin{exe}[4.11]
    If each binding is represented as a name-value pair, each frame represents 
    a table, so we can simplify the implementation by using \vscm{assoc}. We can 
    change the implementation by rewriting the following procedures:
    \scm{ch4/4.11.scm}
\end{exe}

\begin{exe}[4.12]
    \label{4.12}
    We can define a procedure that recursively traverses the environment 
    structure and executes the given action when a binding is found for the 
    given variable as shown below. By default, the procedure goes to the 
    enclosing environment if the procedure is not found in the first frame, but 
    a second procedure can be passed as an argument to specify another behavior.

    Implementation for the representation of frames as a pair of lists:
    \scm{ch4/4.12a.scm}
    Implementation for the reperesentation of frames as a list of pairs:
    \scm{ch4/4.12b.scm}
\end{exe}

\begin{exe}[4.13]
    The solutions I read on the internet unbind variables only from the first 
    frame of the environment because modifying the enclosing environment seemed 
    too risky or similar reasons. I chose to delete the first binding found even 
    if it’s not in the first frame: the interpreter implementation already 
    allows us to change bindings in the enclosing environments, e.g. if I define 
    a function
    \vscm{(define (f x) (set! + -) x)}, the sequence of interactions:
    \begin{cscm}
	(+ 2 1)
	(f 2)
	(+ 2 1)
    \end{cscm}
    produces 3, 2 and 1. This choice is thus coherent with the rest of the 
    implementation.

    To add the \vscm{make-unbound!} operation, we add to \vscm{eval} the line:
    \begin{cscm}
	((unbind? exp) (eval-unbind exp env))
    \end{cscm}
    The necessary procedures with the implementation of frames as a pair of 
    lists are:
    \scm{ch4/4.13a.scm}

    The implementation of \vscm{delete-binding-from-frame} is simpler with 
    a list of pairs than with a pair of lists because there is only one list to 
    modify, and the list is headed, so the case where the variable to unbind is 
    the first in the frame need not be handled separately:
    \scm{ch4/4.13b.scm}
\end{exe}

\subsection{Running the Evaluator as a Program}

\begin{exe}[4.14]
    Louis’ \vscm{map} fails because the \vscm{map} procedure from the underlying 
    Scheme is called with a procedure representation from the interpreter as the 
    procedure to apply with the underlying Scheme’s \vscm{apply}, and it 
    considers that representation as a list and not as a procedure.
\end{exe}

\subsection{Data as Programs}

\begin{exe}[4.15]
    Let’s assume that \vscm{(halts? try try)} returns true. Then 
    \vscm{(run-forever)} is executed so \vscm{(try try)} does not halt.

    Let’s assume that on the contrary, \vscm{(halts? try try)} returns false. 
    Then \vscm{(try try)} halts.

    Both assumptions lead to a contradiction, so such a \vscm{halts?} procedure 
    can’t exist.
\end{exe}

\subsection{Internal Definitions}

\begin{exe}[4.16]
    \label{4.16}
    \ \vspace{-20pt}
    \begin{itemize}
        \item[a.] Here is the updated version of \vscm{lookup-variable-value} 
            for the frame representation as a list of pairs, with the 
            abstractions defined in exercise \ref{4.12}:
            \scm{ch4/4.16a.scm}
        \item[b.] The \vscm{scan-out-defines} procedure can be defined as:
            \scm{ch4/4.16b.scm}
            No transformation must be done if no definition is found because 
            \vscm{let} expressions are transformed into procedure applications, 
            so this would lead to infinite loops. The \vscm{*unassigned*} symbol 
            has to be quoted twice so that the returned code contains a quoted 
            symbol.
        \item[c.] It is better to install \vscm{scan-out-defines} in 
            \vscm{make-procedure} than in \vscm{procedure-body}, because the 
            latter is called every time the procedure is applied, while the 
            former is called only when it is defined.
            \scm{ch4/4.16c.scm}
    \end{itemize}
\end{exe}

\begin{exe}[4.17]
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick,
            code/.append style={font=\ttfamily},
            label distance=5mm]
            % Sequential evaluation
            \matrix[column sep=2\nametoenv, column 2/.style={anchor=west},
            label=below:{Sequential evaluation}] (gem1) {
            \node[text width=1cm, align=right] (ge1) {global\\ env};
            & \node[env,minimum width=4cm, minimum height=1cm] (geb1) 
            {};\\[+1.5cm]

            & \node[code] (vars1) {\ <vars>: <vals>}; \\
            \node[text width=1cm, align=right] (e11) {E1};
            & \node[code] (u1) {\ u: <e1>}; \\
            & \node[code] (v1) {\ v: <e2>}; \\
            };

            \begin{scope}[on background layer]
                \node[env, minimum width=4cm, fit=(vars1) (u1) (v1), below=of 
                geb1,yshift=-2mm] (e1b) {};
            \end{scope}

            \draw[->] (ge1) -- (ge1.west -| geb1.west);
            \draw[->] (e11) -- (e11.east -| e1b.west);
            \draw[->] (e1b) -- (geb1);

            % After scanning out defines
            \matrix[column sep=2\nametoenv, column 2/.style={anchor=west},
            right=of gem1, label=below:{After scanning out}] {
            \node[text width=1cm, align=right] (ge2) {global\\ env};
            & \node[env,minimum width=4cm, minimum height=1cm] (geb2) 
            {};\\[+1.5cm]

            \node[text width=1cm, align=right] (e12) {E1};
            & \node[code] (vars2) {\ <vars>: <vals>}; \\[+1.5cm]

            \node[text width=1cm, align=right] (e2) {E2};
            & \node[code] (u2) {\ u: <e1>}; \\
            & \node[code] (v2) {\ v: <e2>}; \\
            };

            \begin{scope}[on background layer]
                \node[env, minimum width=4cm, fit=(vars2), below=of 
                geb2,yshift=-2.5mm] (e12b) {};
                \node[env, minimum width=4cm, fit=(u2) (v2), below=of 
                e12b,yshift=-1mm] (e2b) {};
            \end{scope}

            \draw[->] (ge2) -- (ge2.west -| geb2.west);
            \draw[->] (e12) -- (e12.east -| e12b.west);
            \draw[->] (e12b) -- (geb2);
            \draw[->] (e2) -- (e2.east -| e2b.west);
            \draw[->] (e2b) -- (e12b);
        \end{tikzpicture}
        \caption{Environment structures in which \vscm{<e3>} is evaluated when 
        the definitions are interpreted sequentially and after scanning out.}
        \label{4.17fig}
    \end{figure}
    Figure \ref{4.17fig} shows the environment structures in which \vscm{<e3>} 
    is evaluated when the definitions are interpreted sequentially and when they 
    are scanned out. In the later case, there is an extra frame because 
    \vscm{let} corresponds to a \vscm{lambda} application.

    This difference in environment structure makes no difference in a correct 
    program’s behavior because the same bindings are accessible when the body of 
    the procedure is evaluated, and since the inner \vscm{let} contains the 
    whole body of the outer lambda, both frames in the later case always go 
    together: if the outer lambda returns a procedure, its environment will be 
    E2, it can never be E1, so there can be no lost bindings.

    A possible solution would be to move all the inner definitions to the top of 
    the procedure body. This will work only if the values of the defined 
    variables don’t use the value of a variable defined later. This can be 
    implemented in the following way:
    \scm{ch4/4.17.scm}
\end{exe}

\begin{exe}[4.18]
    This procedure won’t work if internal definitions are scanned out as in this 
    exercise because the value of \vscm{y} is needed to evaluate the value of 
    \vscm{dy}, and in the exercise the value has been computed but not yet 
    assigned to \vscm{y}.

    It works if internal definitions are scanned out as shown in the text.
\end{exe}

\begin{exe}[4.19]
    Inner definitions should be simultaneous, so Eva is right, but if it’s too 
    difficult to implement internal definitions so they behave that way, it’s 
    better to signal an error than to use an incorrect value as Ben suggests.

    To implement Eva’s idea, we would have to sort the definitions so that if 
    the value of a defined variable is needed to compute another’s value, it 
    should come first. However, it won’t always be possible, definitions such as
    \begin{cscm}
	(define (f x)
	    (define a (+ b 5))
	    (define b (+ a 1))
	    <exps>)
    \end{cscm}
    should result in an error. But there are cases of mutual recursion that 
    work, so it’s not enough to scan the defined symbols’ names in other defined 
    symbols’ values to order the definitions: mutually recursive procedure 
    definitions are not problematic as long as neither procedure is called 
    before both are defined. Mutual recursion is not problematic either in cases 
    where evaluation is delayed, as in the \vscm{solve} example. A symbol could 
    also appear at a place where it will never be evaluated, for instance:
    \begin{cscm}
	(define (f x)
	    (define a (if (> 0 1) (* b 2) 3))
	    (define b 5)
	    <exps>)
    \end{cscm}
    So it seems difficult to implement a general solution that does what Eva 
    prefers.

    \medskip

    Another possible solution is to make definitions and assignments lazy by 
    automatically delaying their values’ evaluation, and forcing them only when 
    a variable’s value is looked up. This is a big change to Scheme’s evaluation 
    order, but since we have already seen how to use \vscm{delay} and 
    \vscm{force} in section \ref{streams} this is not difficult to implement. We 
    need to redefine \vscm{eval-definition} and \vscm{eval-assignment} so they 
    delay the values’ evaluation:
    \scm{ch4/4.19a.scm}
    Then we must call \vscm{force} when we look up a variable’s value, for 
    instance by modifying the \vscm{variable?} case in \vscm{eval}:
    \scm{ch4/4.19b.scm}
\end{exe}

\begin{exe}[4.20]
    \ \vspace{-20pt}
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick,
            code/.append style={font=\ttfamily},
	    label distance=5mm,
	    env/.append style={minimum width=3cm, minimum height=1cm}]
	    % With letrec
	    \matrix[column sep=2\nametoenv, column 2/.style={anchor=west}, 
	    label={[xshift=1cm]above:{With letrec}}] (gem1) {
            \node[text width=1cm, align=right] (ge1) {global\\ env};
	    & \node[code] (gec1) {\ f: ...};\\[+1.5cm]

	    \node[text width=1cm, align=right] (e111) {E1};
	    & \node[code] (x1) {\ x: 5}; \\[+1.5cm]

	    \node[text width=1cm, align=right] (e11) {E2};
	    & \node[code] (even1) {\ even?:}; \\
	    & \node[code] (odd1) {\ odd?:}; \\
	    };

            \begin{scope}[on background layer]
		\node[env, fit=(gec1), xshift=2\nametoenv] (geb1) {};
		\node[env, fit=(x1), below=of geb1, yshift=-2mm] (e21b) {};
		\node[env, fit=(even1) (odd1), below=of e21b] (e1b) {};
            \end{scope}

	    \coordinate (odd1px) at ($ (e1b.south west)!.5!(e1b.south) $);
	    \coordinate[below=of odd1px] (odd1p);
	    \procedure{odd1p}{oc1}{oe1}
	    \draw[->] (oe1) -- (oe1 |- e1b.south);
	    \draw[->] (odd1.south -| odd1p) -- ($ (odd1p) + (0, \circleradius) 
	    $);

	    \coordinate (even1px) at ($ (e1b.south)!.5!(e1b.south east) $);
	    \coordinate[below=of even1px] (even1p);
	    \procedure{even1p}{ec1}{ee1}
	    \draw[->] (ee1) -- (ee1 |- e1b.south);
	    \draw[->] (even1.east) -| ($ (even1p) + (0, \circleradius) $);

            \draw[->] (ge1) -- (ge1.west -| geb1.west);
            \draw[->] (e11) -- (e11.east -| e1b.west);
	    \draw[->] (e111) -- (e111.east -| e21b.west);
	    \draw[->] (e21b) -- (geb1);
	    \draw[->] (e1b) -- (e21b);

	    % With let
	    \matrix[right=3cm of gem1, column sep=2\nametoenv, column 
	    2/.style={anchor=west},
	    label={[xshift=1cm]above:{With let}}] {
	    \node[text width=1cm, align=right] (ge2) {global\\ env};
	    & \node[code] (gec2) {\ f: ...};\\[+1.5cm]

	    \node[text width=1cm, align=right] (e112) {E1};
	    & \node[code] (x2) {\ x: 5}; \\[+1.5cm]

	    \node[text width=1cm, align=right] (e12) {E2};
	    & \node[code] (even2) {\ even?:}; \\
	    & \node[code] (odd2) {\ odd?:}; \\
	    };

            \begin{scope}[on background layer]
		\node[env, fit=(gec2), xshift=2\nametoenv] (geb2) {};
		\node[env, fit=(x2), below=of geb2, yshift=-2mm] (e22b) {};
		\node[env, fit=(even2) (odd2), below=of e22b] (e2b) {};
            \end{scope}

	    \coordinate (odd2px) at ($ (e2b.south west)!.5!(e2b.south) $);
	    \coordinate[below=of odd2px] (odd2p);
	    \procedure{odd2p}{oc2}{oe2}
	    \draw[->] (oe2) -- ($ (oe2) + (0,-.8cm) $) -- ++(3cm,0) |-
	    ($ (e22b.east)!.4!(e22b.north east) $);
	    \draw[->] (odd2.south -| odd2p) -- ($ (odd2p) + (0, \circleradius) 
	    $);

	    \coordinate (even2px) at ($ (e2b.south)!.5!(e2b.south east) $);
	    \coordinate[below=of even2px] (even2p);
	    \procedure{even2p}{ec2}{ee2}
	    \draw[->] (ee2) -- ($ (ee2) + (1cm,0) $) |-
	    ($ (e22b.east)!.4!(e22b.south east) $);
	    \draw[->] (even2.east) -| ($ (even2p) + (0, \circleradius) $);

            \draw[->] (ge2) -- (ge2.west -| geb2.west);
            \draw[->] (e12) -- (e12.east -| e2b.west);
	    \draw[->] (e112) -- (e112.east -| e22b.west);
	    \draw[->] (e22b) -- (geb2);
	    \draw[->] (e2b) -- (e22b);
	\end{tikzpicture}
	\caption{Environment structures in which \vscm{<rest of body of f>} is 
	evaluated during evaluation of the expression \vscm{(f 5)}.}
	\label{4.20fig}
    \end{figure}
    \begin{itemize}
	\item[a.] \vscm{Letrec} can be implemented as shown below. This is very 
	    similar to exercise \ref{4.16}, so the code could be mutualized:
	    \scm{ch4/4.20.scm}
	\item[b.] Figure \ref{4.20fig} shows the environment structures in which 
	    the \vscm{<rest of body of f>} is evaluated during evaluation of the 
	    expression \vscm{(f 5)}, first with \vscm{letrec}, then with 
	    \vscm{let}. With \vscm{letrec}, the values of \vscm{odd?} and 
	    \vscm{even?} are evaluated in an environment where the bindings 
	    already exist, so the procedures created point to an environment 
	    where the other is defined. With \vscm{let}, the values of 
	    \vscm{even?} and \vscm{odd?} are evaluated before the bindings 
	    exist, so they point to an environment where they are undefined and 
	    the recursive calls won’t work.
    \end{itemize}
\end{exe}

\begin{exe}[4.21]
    \ \vspace{-20pt}
    \begin{itemize}
	\item[a.] The trick used here is to modify the recursive procedure 
	    (\vscm{(lambda (ft k) ...)} in the exercise) so it takes as an 
	    additional parameter the procedure to call where a recursive call 
	    would be used otherwise, and the argument used is the modified 
	    procedure itself. The first inner \vscm{lambda}
	    (\vscm{(lambda (fact) ...)}) is used to do the initial call to the 
	    modified (derecursified?) procedure.

	    The Fibonacci numbers can be computed similarly:
	    \scm{ch4/4.21a.scm}

	\item[b.] This time, since there are two mutually recursive procedures, 
	    two procedure parameters are needed to pass around the procedures to 
	    call when we are not in the terminal case.
	    \scm{ch4/4.21b.scm}
    \end{itemize}
\end{exe}

\subsection{Separating Syntactic Analysis from Execution}
\label{analysis}

\begin{exe}[4.22]
    Since \vscm{let} is a derived form, all that’s needed to support it is to 
    add the following line to \vscm{analyze}:
    \scm{ch4/4.22a.scm}
    \begin{comp}
        We can just as easily add support for all the derived forms implemented 
        in the previous exercises:
        \scm{ch4/4.22b.scm}
        We need to implement \vscm{analyze} procedures to support the versions of 
        \vscm{or} and \vscm{and} defined with special evaluation functions, as 
        well as \vscm{make-unbound!}:
        \scm{ch4/4.22c.scm}
        Lastly, we can implement scanning out of internal definitions as in 
        exercise \ref{4.16} by calling \vscm{scan-out-defines} in 
        \vscm{analyze-lambda}:
        \scm{ch4/4.22d.scm}
    \end{comp}
\end{exe}

\begin{exe}[4.23]
    If the sequence has just one expression, the procedure produced by Alyssa’s 
    program tests the \vscm{cdr} of \vscm{procs}, finds that it’s null and then 
    calls the first procedure. The program in the text does the test during 
    analysis and returns the result of analyzing the expression directly, so the 
    only work done during evaluation is to call it.

    For a sequence with two expressions, Alyssa’s procedure will loop through 
    the procedures each time the sequence is evaluated, while the procedure from 
    the text loops through them only once during analysis.
\end{exe}

\begin{exe}[4.24]
    I wrote a small procedure to interpret code with the interpreter without 
    using the REPL (I should probably have done that some time ago…):
    \scm{ch4/4.24a.scm}
    I then ran the following two tests: one with a recursive procedure and the 
    other with a non-recursive procedure:
    \scm{ch4/4.24b.scm}
    With the evaluator in this section, the first test evaluates in 7877~ms, the 
    second one in 36~ms.

    With the original version, the first test evaluates in 16024~ms, the second 
    one in 79~ms.

    Separating analysis from execution speeds up execution by a factor of more 
    than two, so we can estimate that about half the time was spent in analysis 
    with the original version of the evaluator.
\end{exe}

\section{Variations on a Scheme―Lazy Evaluation}

\subsection{Normal Order and Applicative Order}

\begin{exe}[4.25]
    If we attempt to evaluate \vscm{(factorial 5)}, we will get an infinite loop 
    since Scheme attempts to evaluate the second argument to \vscm{unless} 
    recursively.

    It would work in a normal-order language.
\end{exe}

\begin{exe}[4.26]
    Ben is right that it’s possible to define \vscm{unless} as a derived 
    expression:
    \scm{ch4/4.26a.scm}
    Then we just have to have the following line to \vscm{eval}:
    \scm{ch4/4.26b.scm}
    or the following line to \vscm{analyze} for the evaluator from section 
    \ref{analysis}:
    \scm{ch4/4.26c.scm}

    It would be useful to have \vscm{unless} available as a procedure rather 
    than a special form to use it as a parameter to higher-order procedures, for 
    instance in \vscm{(map unless bools list1 list2)}, which returns a list 
    where the element of index $i$ is:
    \begin{itemize}
	\item the element of index $i$ of \vscm{list2} if the element of index 
	    $i$ in the list \vscm{bools} is true;
	\item the element of index $i$ of \vscm{list1} otherwise.
    \end{itemize}
\end{exe}

\subsection{An Interpreter with Lazy Evaluation}

\begin{exe}[4.27]
    The value of \vscm{count} the first time is 1 because the body of the outer 
    \vscm{id} in the definition of \vscm{w} was evaluated. Then the value of 
    \vscm{w} is 10 as expected, and once \vscm{w} has been forced the value of 
    \vscm{count} is 2 because the inner \vscm{id} in the definition of \vscm{w} 
    was evaluated as well.
\end{exe}
