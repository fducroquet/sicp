\chapter{Metalinguistic Abstraction}

\section{The Metacircular Evaluator}

\subsection{The Core of the Evaluator}

\begin{exe}[4.1]
    We can put the value to evaluate first inside a \vscm{let} expression. Since 
    the \vscm{let} is transformed into a \vscm{lambda} internally, we know that 
    its argument will be evaluated before the body of the \vscm{let}.
    \scm{ch4/4.01.scm}
\end{exe}

\subsection{Representing Expressions}

\begin{exe}[4.2]
    \ \vspace{-20pt}
    \begin{itemize}
	\item[a.] The test to determine whether an expression is a procedure 
	    just checks whether it is a pair, so it will return true for all 
	    list expressions: \vscm{if}, \vscm{cond}, \vscm{begin}, 
	    \vscm{define}, \vscm{set!}, etc., and the evaluator will try to 
	    apply the procedure \vscm{if}, \vscm{cond}, etc. to the rest of the 
	    arguments. It’s not possible to transform the special forms into 
	    procedures because all the arguments of a procedure are evaluated 
	    before evaluation.
	\item[b.] The only required change to \vscm{eval} is to put the 
	    \vscm{application?} test first. Then we only need changing the 
	    definition of the \vscm{application?} predicate and the associated 
	    selectors so they reflect the new syntax.
	    \scm{ch4/4.02.scm}
    \end{itemize}
\end{exe}

\begin{exe}[4.3]
    As in exercise \ref{2.73}, a few cases can’t be assimilated to the 
    data-directed dispatch because they correspond to untagged data: here it’s 
    the case of \vscm{variable?}, \vscm{self-evaluating?} and 
    \vscm{application?}. If we had kept Louis’ idea from the previous exercise 
    to start procedure applications with \vscm{call}, \vscm{application?} could 
    have been assimilated into the dispatch. Since we don’t keep this idea, we 
    have to redefine the \vscm{application?} predicate: if we keep it as 
    \vscm{pair?} we can’t put it before the dispatch because all the special 
    forms will be considered as procedure applications, and we can’t put it 
    after the dispatch either because the procedure won’t be found in the table 
    and it will cause an error. So I consider that every expression for which no 
    procedure of the correct type is found in the table is a procedure 
    application. I used a two-dimensional table as in chapter 2, though 
    a one-dimensional table would be enough if we don’t do any other dispatch on 
    the expressions’ type.
    \scm{ch4/4.03.scm}
\end{exe}

\begin{exe}[4.4]
    If we define specific evaluation procedures \vscm{eval-and} and 
    \vscm{eval-or}, we have to add the following two lines to the definition of 
    \vscm{eval}
    \scm{ch4/4.04a.scm}
    Then we can implement the predicates, selectors and the evaluation 
    procedures in the following way:
    \scm{ch4/4.04b.scm}
    If \vscm{and} and {or} are implemented as derived expressions, the 
    predicates and selectors don’t change, but the lines regarding \vscm{and} 
    and \vscm{or} in \vscm{eval} are replaced by:
    \scm{ch4/4.04c.scm}
    And the procedures transforming \vscm{and} and \vscm{or} expressions into 
    \vscm{if} expressions can be defined as:
    \scm{ch4/4.04d.scm}
\end{exe}

\begin{exe}[4.5]
    We only need to add the appropriate predicate and selectors for this type of 
    clause so that the appropriate action is taken if the predicate evaluates to 
    a true value.
    \scm{ch4/4.05.scm}
\end{exe}

\begin{exe}[4.6]
    The only necessary modification to \vscm{eval} is to add the line:
    \scm{ch4/4.06b.scm}
    Then we can define the appropriate predicate and selectors and the 
    transformation procedure \vscm{let->combination} in the following way:
    \scm{ch4/4.06.scm}
\end{exe}

\begin{exe}[4.7]
    A \vscm{let*} expression can be rewritten as a set of nested \vscm{let} 
    expressions defining only one binding at a time, so that the second binding 
    is defined in the body of the first \vscm{let} etc. For instance, the 
    example from the book becomes:
    \scm{ch4/4.07b.scm}
    If we have already implemented \vscm{let}, it is sufficient to rewrite 
    \vscm{let*} expressions in terms of \vscm{let} expressions to handle them. 
    This can be done in the following way:
    \scm{ch4/4.07.scm}
\end{exe}

\begin{exe}[4.8]
    To support named \vscm{let}, we modify the selectors for \vscm{let} so they 
    handle both named \vscm{let}s and ordinary \vscm{let}s, and 
    \vscm{let->combination} so the generated code creates a procedure with the 
    given name instead of a lambda.
    \scm{ch4/4.08.scm}
\end{exe}

\begin{exe}[4.9]
    I chose to implement three iterative control structures: a \vscm{while} 
    loop, an \vscm{until} loop, and a \vscm{for} loop. The return value of all 
    the expressions described is \vscm{false}, so they are useful only for their 
    side effects. The \vscm{until} and the \vscm{for} constructs are derived 
    from \vscm{while}.
    \begin{itemize}
        \item[\emph{while}] The syntax of the \vscm{while} loop is
            \vscm{(while <predicate> <body>)}. The predicate must consist of 
            a single expression. The body can consist of several expressions. 
            The body is executed while the predicate is true. If the predicate 
            is false from the beginning, the body is never evaluated.

            For instance, the evaluation of the following code prints the 
            numbers from 0 to 5 inclusive, each on a new line:
            \begin{cscm}
                (define x 0)
                (while (<= x 5)
                    (display x)
                    (newline)
                    (set! x (+ x 1)))
            \end{cscm}
            The transformation procedure for \vscm{while} expressions turns them 
            into the definition of a recursive procedure that uses the predicate 
            to decide whether to execude the body of the \vscm{while} or not, 
            followed by a call to this procedure. The procedure name is 
            generated by \vscm{gensym}, so it does not conflict with other names 
            in the program, and if two \vscm{while} are evaluated in the same 
            environment, the generated procedures will have different names.
            \scm{ch4/4.09while.scm}
        \item[\emph{until}] The syntax of the \vscm{until} loop is
            \vscm{(until <predicate> <body>)}, and such an expression is 
            equivalent to \vscm{(while (not <predicate>) <body>)}. For instance, 
            the following code prints the numbers from 0 to 4 inclusive, each on 
            a new line:
            \begin{cscm}
                (define x 0)
                (until (= x 5)
                    (display x)
                    (newline)
                    (set! x (+ x 1)))
            \end{cscm}
            \vscm{Until} expressions are easily derived from \vscm{while} 
            expressions in the following way:
            \scm{ch4/4.09until.scm}
        \item[\emph{for}] The general syntax of the \vscm{for} loop is
            \vscm{(for (<var> <start> <end-test> [<inc-exp>]) <body>)}. The body 
            can consist of several expressions. The other parts are:
            \begin{itemize}
                \item \vscm{<var>}: the name of the variable whose value is 
                    bound by the \vscm{for} loop.
                \item \vscm{<start>}: an expression giving the initial value of 
                    the variable.
                \item \vscm{<end-test>} can be either:
                    \begin{itemize}
                        \item an expression where \vscm{<var>} appears as a free 
                            variable, for instance \vscm{(< <var> 3)}. The body 
                            of the \vscm{for} is evaluated as long as the 
                            evaluation of this expression with the current value 
                            of \vscm{<var>} returns \vscm{true}.
                        \item an expression not depending on the variable bound 
                            by the \vscm{for}, whose evaluation must return 
                            a number. This is equivalent to either
                            \vscm{(<= <var> <end-test>)} or
                            \vscm{(>= <var> <end-test>)}, depending on whether 
                            the returned value is greater or smaller than the 
                            initial value.
                    \end{itemize}
                \item \vscm{<inc-exp>} can be either:
                    \begin{itemize}
                        \item an expression where \vscm{<var>} appears as a free 
                            variable, for instance \vscm{(+ <var> 2)}. It is 
                            evaluated to update the value of \vscm{<var>} before 
                            evaluating (or not) the body of the \vscm{for} 
                            again.
                        \item an expression not depending on the variable bound 
                            by the \vscm{for}, whose evaluation must return 
                            a number. This is equivalent to specifying
                            \vscm{(+ <var> <inc-exp>)}.
                        \item empty, in which case it will be assumed to be 1.
                    \end{itemize}
            \end{itemize}
            For instance, the following expressions all print the numbers from 
            0 to 5:
            \begin{cscm}
                (for (x 1 (<= x 5) (+ x 1)) (display x) (newline))

                (for (x 1 (<= x 5) 1) (display x) (newline))

                (for (x 1 (<= x 5)) (display x) (newline))

                (for (x 1 5 (+ x 1)) (display x) (newline))

                (for (x 1 5 1) (display x) (newline))

                (for (x 1 5) (display x) (newline))
            \end{cscm}
            Using a step other than one, we can print 1, .8, .6, .4, .2 and 
            0 with:
            \begin{cscm}
                (for (x 1 -.1 -.2)
                    (display x) (newline))
            \end{cscm}
            With an update function that is not simply an addition or 
            subtraction, the following prints 16, 8, 4, 2 and 1.
            \begin{cscm}
                (for (x 16 1 (/ x 2))
                    (display x) (newline))
            \end{cscm}
            It’s possible to use nested \vscm{for}s, for instance:
            \begin{cscm}
            (for (x 0 5)
                (for (y (+ x 1) (+ x 2))
                    (display x)
                    (display ", ")
                    (display y)
                    (newline)))
            \end{cscm}
            The output is:
            \begin{cscm}
                0, 1
                0, 2
                1, 2
                1, 3
                2, 3
                2, 4
                3, 4
                3, 5
                4, 5
                4, 6
                5, 6
                5, 7
            \end{cscm}
    \end{itemize}
    The implementation is more complex than that of \vscm{while}, because 
    several cases have to be considered. I had to write a procedure that checks 
    whether a given variable appears as a free variable in a given expression. 
    Then the different cases have to be considered when constructing the 
    predicate that tests whether to interrupt the loop or not, and the procedure 
    that updates the value of the variable. The \vscm{for} expression is then 
    transformed in a \vscm{let} expression containing a \vscm{while}.
    \scm{ch4/4.09for.scm}
\end{exe}

\begin{exe}[4.10]
    It’s easy to modify the symbol used as the \vscm{car} of an expression to 
    define its type: we only need changing the predicate (and the associated 
    constructor if any was defined) for this type of expression. For instance, 
    we can replace \vscm{cond} with \vscm{case}, \vscm{and} with \vscm{&&}, and 
    \vscm{or} with \vscm{||} with the following code:
    \scm{ch4/4.10a.scm}

    We can replace \vscm{not} with \vscm{!} by replacing
    \vscm{(list 'not not)} with \vscm{(list '! not)} in the list of primitive 
    procedures.

    I also modified the selectors for procedure application so that
    \vscm{(proc args)} becomes \vscm{(proc (args))}. This change actually makes 
    the syntax more complex since e.g. \vscm{(not (> x 3))} has to be written 
    \vscm{(! ((> (x 3))))}, it’s just for the sake of the example.
    \scm{ch4/4.10b.scm}

    I think that more dramatic changes such as replacing the parentheses with 
    brackets would require a lot of work since currently we rely on the 
    underlying Scheme for list processing.
\end{exe}

\subsection{Evaluator Data Structures}

\begin{exe}[4.11]
    If each binding is represented as a name-value pair, each frame represents 
    a table, so we can simplify the implementation by using \vscm{assoc}. We can 
    change the implementation by rewriting the following procedures:
    \scm{ch4/4.11.scm}
\end{exe}

\begin{exe}[4.12]
    \label{4.12}
    We can define a procedure that recursively traverses the environment 
    structure and executes the given action when a binding is found for the 
    given variable as shown below. By default, the procedure goes to the 
    enclosing environment if the procedure is not found in the first frame, but 
    a second procedure can be passed as an argument to specify another behavior.

    Implementation for the representation of frames as a pair of lists:
    \scm{ch4/4.12a.scm}
    Implementation for the reperesentation of frames as a list of pairs:
    \scm{ch4/4.12b.scm}
\end{exe}

\begin{exe}[4.13]
    The solutions I read on the internet unbind variables only from the first 
    frame of the environment because modifying the enclosing environment seemed 
    too risky or similar reasons. I chose to delete the first binding found even 
    if it’s not in the first frame: the interpreter implementation already 
    allows us to change bindings in the enclosing environments, e.g. if I define 
    a function
    \vscm{(define (f x) (set! + -) x)}, the sequence of interactions:
    \begin{cscm}
	(+ 2 1)
	(f 2)
	(+ 2 1)
    \end{cscm}
    produces 3, 2 and 1. This choice is thus coherent with the rest of the 
    implementation.

    To add the \vscm{make-unbound!} operation, we add to \vscm{eval} the line:
    \begin{cscm}
	((unbind? exp) (eval-unbind exp env))
    \end{cscm}
    The necessary procedures with the implementation of frames as a pair of 
    lists are:
    \scm{ch4/4.13a.scm}

    The implementation of \vscm{delete-binding-from-frame} is simpler with 
    a list of pairs than with a pair of lists because there is only one list to 
    modify, and the list is headed, so the case where the variable to unbind is 
    the first in the frame need not be handled separately:
    \scm{ch4/4.13b.scm}
\end{exe}

\subsection{Running the Evaluator as a Program}

\begin{exe}[4.14]
    Louis’ \vscm{map} fails because the \vscm{map} procedure from the underlying 
    Scheme is called with a procedure representation from the interpreter as the 
    procedure to apply with the underlying Scheme’s \vscm{apply}, and it 
    considers that representation as a list and not as a procedure.
\end{exe}

\subsection{Data as Programs}

\begin{exe}[4.15]
    Let’s assume that \vscm{(halts? try try)} returns true. Then 
    \vscm{(run-forever)} is executed so \vscm{(try try)} does not halt.

    Let’s assume that on the contrary, \vscm{(halts? try try)} returns false. 
    Then \vscm{(try try)} halts.

    Both assumptions lead to a contradiction, so such a \vscm{halts?} procedure 
    can’t exist.
\end{exe}

\subsection{Internal Definitions}

\begin{exe}[4.16]
    \ \vspace{-20pt}
    \begin{itemize}
        \item[a.] Here is the updated version of \vscm{lookup-variable-value} 
            for the frame representation as a list of pairs, with the 
            abstractions defined in exercise \ref{4.12}:
            \scm{ch4/4.16a.scm}
        \item[b.] The \vscm{scan-out-defines} procedure can be defined as:
            \scm{ch4/4.16b.scm}
            No transformation must be done if no definition is found because 
            \vscm{let} expressions are transformed into procedure applications, 
            so this would lead to infinite loops. The \vscm{*unassigned*} symbol 
            has to be quoted twice so that the returned code contains a quoted 
            symbol.
        \item[c.] It is better to install \vscm{scan-out-defines} in 
            \vscm{make-procedure} than in \vscm{procedure-body}, because the 
            latter is called every time the procedure is applied, while the 
            former is called only when it is defined.
            \scm{ch4/4.16c.scm}
    \end{itemize}
\end{exe}

\begin{exe}[4.17]
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick,
            code/.append style={font=\ttfamily},
            label distance=5mm]
            % Sequential evaluation
            \matrix[column sep=2\nametoenv, column 2/.style={anchor=west},
            label=below:{Sequential evaluation}] (gem1) {
            \node[text width=1cm, align=right] (ge1) {global\\ env};
            & \node[env,minimum width=4cm, minimum height=1cm] (geb1) 
            {};\\[+1.5cm]

            & \node[code] (vars1) {\ <vars>: <vals>}; \\
            \node[text width=1cm, align=right] (e11) {E1};
            & \node[code] (u1) {\ u: <e1>}; \\
            & \node[code] (v1) {\ v: <e2>}; \\
            };

            \begin{scope}[on background layer]
                \node[env, minimum width=4cm, fit=(vars1) (u1) (v1), below=of 
                geb1,yshift=-2mm] (e1b) {};
            \end{scope}

            \draw[->] (ge1) -- (ge1.west -| geb1.west);
            \draw[->] (e11) -- (e11.east -| e1b.west);
            \draw[->] (e1b) -- (geb1);

            % After scanning out defines
            \matrix[column sep=2\nametoenv, column 2/.style={anchor=west},
            right=of gem1, label=below:{After scanning out}] {
            \node[text width=1cm, align=right] (ge2) {global\\ env};
            & \node[env,minimum width=4cm, minimum height=1cm] (geb2) 
            {};\\[+1.5cm]

            \node[text width=1cm, align=right] (e12) {E1};
            & \node[code] (vars2) {\ <vars>: <vals>}; \\[+1.5cm]

            \node[text width=1cm, align=right] (e2) {E2};
            & \node[code] (u2) {\ u: <e1>}; \\
            & \node[code] (v2) {\ v: <e2>}; \\
            };

            \begin{scope}[on background layer]
                \node[env, minimum width=4cm, fit=(vars2), below=of 
                geb2,yshift=-2.5mm] (e12b) {};
                \node[env, minimum width=4cm, fit=(u2) (v2), below=of 
                e12b,yshift=-1mm] (e2b) {};
            \end{scope}

            \draw[->] (ge2) -- (ge2.west -| geb2.west);
            \draw[->] (e12) -- (e12.east -| e12b.west);
            \draw[->] (e12b) -- (geb2);
            \draw[->] (e2) -- (e2.east -| e2b.west);
            \draw[->] (e2b) -- (e12b);
        \end{tikzpicture}
        \caption{Environment structures in which \vscm{<e3>} is evaluated when 
        the definitions are interpreted sequentially and after scanning out.}
        \label{4.17fig}
    \end{figure}
    Figure \ref{4.17fig} shows the environment structures in which \vscm{<e3>} 
    is evaluated when the definitions are interpreted sequentially and when they 
    are scanned out. In the later case, there is an extra frame because 
    \vscm{let} corresponds to a \vscm{lambda} application.

    This difference in environment structure makes no difference in a correct 
    program’s behavior because the same bindings are accessible when the body of 
    the procedure is evaluated, and since the inner \vscm{let} contains the 
    whole body of the outer lambda, both frames in the later case always go 
    together: if the outer lambda returns a procedure, its environment will be 
    E2, it can never be E1, so there can be no lost bindings.

    A possible solution would be to move all the inner definitions to the top of 
    the procedure body. This will work only if the values of the defined 
    variables don’t use the value of a variable defined later. This can be 
    implemented in the following way:
    \scm{ch4/4.17.scm}
\end{exe}

\begin{exe}[4.18]
    This procedure won’t work if internal definitions are scanned out as in this 
    exercise because the value of \vscm{y} is needed to evaluate the value of 
    \vscm{dy}, and in the exercise the value has been computed but not yet 
    assigned to \vscm{y}.

    It works if internal definitions are scanned out as shown in the text.
\end{exe}
