\chapter{Metalinguistic Abstraction}

\section{The Metacircular Evaluator}

\subsection{The Core of the Evaluator}

\begin{exe}[4.1]
    We can put the value to evaluate first inside a \vscm{let} expression. Since 
    the \vscm{let} is transformed into a \vscm{lambda} internally, we know that 
    its argument will be evaluated before the body of the \vscm{let}.
    \scm{ch4/4.01.scm}
\end{exe}

\subsection{Representing Expressions}

\begin{exe}[4.2]
    \ \vspace{-20pt}
    \begin{itemize}
	\item[a.] The test to determine whether an expression is a procedure 
	    just checks whether it is a pair, so it will return true for all 
	    list expressions: \vscm{if}, \vscm{cond}, \vscm{begin}, 
	    \vscm{define}, \vscm{set!}, etc., and the evaluator will try to 
	    apply the procedure \vscm{if}, \vscm{cond}, etc. to the rest of the 
	    arguments. It’s not possible to transform the special forms into 
	    procedures because all the arguments of a procedure are evaluated 
	    before evaluation.
	\item[b.] The only required change to \vscm{eval} is to put the 
	    \vscm{application?} test first. Then we only need changing the 
	    definition of the \vscm{application?} predicate and the associated 
	    selectors so they reflect the new syntax.
	    \scm{ch4/4.02.scm}
    \end{itemize}
\end{exe}

\begin{exe}[4.3]
    As in exercise \ref{2.73}, a few cases can’t be assimilated to the 
    data-directed dispatch because they correspond to untagged data: here it’s 
    the case of \vscm{variable?}, \vscm{self-evaluating?} and 
    \vscm{application?}. If we had kept Louis’ idea from the previous exercise 
    to start procedure applications with \vscm{call}, \vscm{application?} could 
    have been assimilated into the dispatch. Since we don’t keep this idea, we 
    have to redefine the \vscm{application?} predicate: if we keep it as 
    \vscm{pair?} we can’t put it before the dispatch because all the special 
    forms will be considered as procedure applications, and we can’t put it 
    after the dispatch either because the procedure won’t be found in the table 
    and it will cause an error. So I consider that every expression for which no 
    procedure of the correct type is found in the table is a procedure 
    application. I used a two-dimensional table as in chapter 2, though 
    a one-dimensional table would be enough if we don’t do any other dispatch on 
    the expressions’ type.
    \scm{ch4/4.03.scm}
\end{exe}

\begin{exe}[4.4]
    If we define specific evaluation procedures \vscm{eval-and} and 
    \vscm{eval-or}, we have to add the following two lines to the definition of 
    \vscm{eval}
    \scm{ch4/4.04a.scm}
    Then we can implement the predicates, selectors and the evaluation 
    procedures in the following way:
    \scm{ch4/4.04b.scm}
    If \vscm{and} and {or} are implemented as derived expressions, the 
    predicates and selectors don’t change, but the lines regarding \vscm{and} 
    and \vscm{or} in \vscm{eval} are replaced by:
    \scm{ch4/4.04c.scm}
    And the procedures transforming \vscm{and} and \vscm{or} expressions into 
    \vscm{if} expressions can be defined as:
    \scm{ch4/4.04d.scm}
\end{exe}

\begin{exe}[4.5]
    We only need to add the appropriate predicate and selectors for this type of 
    clause so that the appropriate action is taken if the predicate evaluates to 
    a true value.
    \scm{ch4/4.05.scm}
\end{exe}

\begin{exe}[4.6]
    The only necessary modification to \vscm{eval} is to add the line:
    \scm{ch4/4.06b.scm}
    Then we can define the appropriate predicate and selectors and the 
    transformation procedure \vscm{let->combination} in the following way:
    \scm{ch4/4.06.scm}
\end{exe}

\begin{exe}[4.7]
    A \vscm{let*} expression can be rewritten as a set of nested \vscm{let} 
    expressions defining only one binding at a time, so that the second binding 
    is defined in the body of the first \vscm{let} etc. For instance, the 
    example from the book becomes:
    \scm{ch4/4.07b.scm}
    If we have already implemented \vscm{let}, it is sufficient to rewrite 
    \vscm{let*} expressions in terms of \vscm{let} expressions to handle them. 
    This can be done in the following way:
    \scm{ch4/4.07.scm}
\end{exe}
