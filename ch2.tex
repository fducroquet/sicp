\chapter{Building Abstractions with Data}

\section{Introduction to Data Abstraction}

\subsection{Example: Arithmetic Operations for Rational Numbers}

\begin{exe}[2.1]
    A possibility for a \vscm{make-rat} handling both positive and negative 
    arguments:
    \scm{ch2/2.01.scm}
\end{exe}

\subsection{Abstraction Barriers}

\begin{exe}[2.2]
    Exemple implementation for the representation of segments in a plane:
    \scm{ch2/2.02.scm}
\end{exe}

\begin{exe}[2.3]
    In the following implementation, a rectangle is represented by its two 
    opposite sides, which must have the same orientation. The code makes use of 
    auxiliary procedures defined below.

    I added selectors to access each of the vertices of the rectangle to be 
    able to print rectangles in a uniform format.
    \scm{ch2/2.03.1.scm}

    The procedures that compute the perimeter and area of a rectangle, and the 
    procedure that prints a rectangle, are defined thus:
    \scm{ch2/2.03.perim-area.scm}

    Another possibility is to represent a rectangle by its four vertices:
    \scm{ch2/2.03.2.scm}

    Yet another possibility is to represent a rectangle by two perpendicular 
    segments with the same origin:
    \scm{ch2/2.03.3.scm}

    The procedures \vscm{perim-rect}, \vscm{area-rect} and \vscm{print-rect} 
    work in all three cases.

    \begin{comp}
        The code above makes use of the following auxiliary procedures to check 
        that the input is correct, compute the length of a segment, and print 
        points inline for use in \vscm{print-rect}:
        \scm{ch2/2.03.aux.scm}
    \end{comp}
\end{exe}

\subsection{What Is Meant by Data?}

\begin{exe}[2.4]
    With the representation of pairs given in the exercise, \vscm{(cons x y)} is 
    a procedure that takes as its argument a procedure \vscm{m} with two 
    arguments and returns the result of the application of \vscm{m} to \vscm{x} 
    and \vscm{y}.

    \vscm{(car z)} applies the procedure \vscm{(cons x y)} to the procedure that 
    returns the first of its arguments, so \vscm{(car (cons x y))} yields 
    \vscm{x}.

    Using the substitution model, the successive steps are:
    \scm{ch2/2.04a.scm}

    The corresponding definition of \vscm{cdr} is:
    \scm{ch2/2.04b.scm}
    The method to prove that \vscm{(cdr (cons x y))} yields \vscm{y} is the same 
    as with \vscm{car}.
\end{exe}

\begin{exe}[2.5]
    If $a$ and $b$ are known, we can compute $2^a 3^b$, and since the 
    decomposition of integers as a product of primes is unique, it’s possible to 
    find $a$ and $b$ from the value of $2^a 3^b$.

    The procedures \vscm{cons}, \vscm{car}, and \vscm{cdr} corresponding to this 
    representation can be defined as:
    \scm{ch2/2.05.scm}
\end{exe}

\begin{exe}[2.6]
    The successive substitution steps to evaluate \vscm{(add-1 zero)} are:
    \scm{ch2/2.06a.scm}

    In other words, \vscm{one} is a procedure that takes a one-argument 
    procedure as its argument and returns it.

    The substitution steps to evaluate \vscm{(add-1 one)} are:
    \scm{ch2/2.06b.scm}

    In other words, \vscm{two} is a procedure that takes a one-argument 
    procedure $f$ as its argument and returns the procedure $f \circ f$ ($f$ 
    applied twice).

    From these observations, and after remarking that \vscm{zero} is a procedure 
    that takes one argument and always returns the identity procedure, we can 
    make the hypothesis that the $n$th Church numeral is a procedure that takes 
    a one-argument procedure $f$ as its argument and returns the $n$th repeated 
    application of $f$ (see exercise~\ref{1.43}). This can be proved by 
    induction.

    \begin{proof}
        We’ve already shown that it’s true for $0$, $1$ and $2$.
        Let’s assume that it’s true for a positive integer $n$.

        From the induction hypothesis, \vscm{(n f)} is the $n$th repeated 
        application of $f$, so it’s obvious that
        \vscm{(lambda (x) (f ((n f) x)))} is the $(n + 1)$th repeatead 
        application of $f$, so the result is true for $n + 1$, hence it’s true 
        for any positive integer $n$.
    \end{proof}

    To apply a function $n + m$ times, we just need to apply it $m$ times, and 
    then $n$ times more, so \vscm{+} can be defined directly as:
    \scm{ch2/2.06c.scm}
\end{exe}

\subsection{Extended Exercise: Interval Arithmetic}

Let’s first define a function that prints intervals:
\scm{ch2/2.07pre2.scm}

\begin{exe}[2.7]
    Since \vscm{make-interval} has been defined as \vscm{cons}, 
    \vscm{upper-bound} and \vscm{lower-bound} can be defined as \vscm{cdr} and 
    \vscm{car} respectively.
    \scm{ch2/2.07.scm}
\end{exe}

\begin{exe}[2.8]
    With the same reasoning as for division, the subtraction of two intervals is 
    the addition of the first with the opposite of the second.
    The subtraction procedure can thus be defined:
    \scm{ch2/2.08.scm}
\end{exe}

\begin{exe}[2.9]
    Let $[a;b]$ and $[c;d]$ be two intervals.

    Their sum is $[a + c; b + d]$. Its width is $\sfrac{(b + d) - (a + c)}{2} 
    = \sfrac{(b - a)}{2} + \sfrac{(d - c)}{2}$, in other words, the sum’s 
    width is the sum of the widths, so it depends only on the widths of the 
    intervals being added.

    The difference can be defined as the sum with the opposite, and taking the 
    opposite doesn’t change the width, so this is also true for differences.

    For multiplication and division, the width of the result also depends on 
    the values of the bounds. For instance, $[1; 2] \times [2; 3] = [2; 6]$, 
    but $[0; 1] \times [2; 3] = [0; 3]$. In both cases, we multiply two 
    intervals of width $\sfrac{1}{2}$, but the former product has a width of 
    $2$ while the latter has a width of $\sfrac{3}{2}$, so the width of the 
    product is not a function of the widths of the intervals being multiplied.

    Since division can be defined as a multiplication, this is also true for 
    division.
\end{exe}

\begin{exe}[2.10]
    The new code of \vscm{div-interval} could be:
    \scm{ch2/2.10.scm}
\end{exe}

\begin{exe}[2.11]
    There are three cases for each interval:
    \begin{itemize}
        \item the lower bound is positive or null;
        \item the upper bound is negative or null;
        \item the lower bound is negative and the upper bound is positive.
    \end{itemize}
    This results in a total of nine cases, and the only case where the smallest 
    and greatest products can’t be deduced from the signs is when both intervals 
    span zero.

    A procedure taking this suggestion into account is:
    \scm{ch2/2.11.scm}
\end{exe}

\begin{exe}[2.12]
    The procedures \vscm{make-center-percent} and \vscm{percent} can be defined 
    as:
    \scm{ch2/2.12.scm}
\end{exe}

\begin{exe}[2.13]
    Let $c_1, c_2, w_1$ and $w_2$ be the centers and widths of two intervals. We 
    assume that all numbers are positive. The lower and upper bounds of the 
    product are
    $(c_1 \pm w_1) \times (c_2 \pm w_2) = c_1 c_2 \pm (c_1 w_2 + c_2 w_1) + w_1 
    w_2$.

    Since the percentages are small, $w_1 w_2$ is negligible, and the product’s 
    width is $w \approx c_1 w_2 + c_2 w_1$.

    Additionally, if we call the percentage tolerances $p_1$ and $p_2$ 
    respectively, we have $w_i = c_i \times \sfrac{p_i}{100}$ for $i = 1, 2$.

    From there, $w \approx c_1 c_2 \times \sfrac{p_1 + p_2}{100}$, and $c_1 c_2$ 
    is the product’s center, so under the given conditions, the approximate 
    percentage tolerance of the product is the sum of the tolerances of the 
    factors.
\end{exe}

\begin{exe}[2.14]
    TODO
\end{exe}

\begin{exe}[2.15]
    TODO
\end{exe}

\begin{exe}[2.16]
    TODO
\end{exe}

\section{Hierarchical Data and the Closure Property}

\subsection{Representing Sequences}

\begin{exe}[2.17]
    The \vscm{last-pair} procedure can be defined as:
    \scm{ch2/2.17.scm}
\end{exe}

\begin{exe}[2.18]
    The \vscm{reverse} procedure can be defined as:
    \scm{ch2/2.18.scm}
\end{exe}

\begin{exe}[2.19]
    The procedures can be defined respectively as \vscm{car}, \vscm{cdr} and 
    \vscm{null?}.
    \scm{ch2/2.19.scm}

    The order of the list \vscm{coin-values} does not affect the answer produced 
    by \vscm{cc}, because \vscm{cc} gives the total number of combinations, and 
    the relation used for the computation does not depend on a particular order.
\end{exe}

\begin{exe}[2.20]
    A possible solution is:
    \scm{ch2/2.20.scm}
\end{exe}

\begin{exe}[2.21]
    The completed procedures are:
    \scm{ch2/2.21.scm}
\end{exe}

\begin{exe}[2.22]
    With the first procedure, the answer list is in reverse order because the 
    elements are added to it starting from the beginning of the initial list, 
    and the first element added to a list is at its end.

    With the second procedure, the result is not a list because \vscm{cons} is 
    called with a list as its first argument and the element to add as its 
    second argument. To add an element to a list, the order of the arguments 
    should be the opposite.
\end{exe}

\begin{exe}[2.23]
    Here is a possible implementation of \vscm{for-each}:
    \scm{ch2/2.23.scm}
\end{exe}

\subsection{Hierarchical Structures}

\begin{exe}[2.24]
    The result given by the interpreter is \vscm{(1 (2 (3 4)))}. To represent 
    the corresponding box-and-pointer structure in terms of pairs, one must use 
    the equality of \vscm{(list 1 (list 2 (list 3 4)))} and
    \vscm{(cons 1 (cons (list 2 (list 3 4)) nil))}, and similar equalities for 
    the two other lists.

    \begin{figure}
        \begin{center}
            TODO (too time-consuming…)
        \end{center}
        \caption{Box-and-pointer-structure of \vscm{(1 (2 (3 4)))}.}
    \end{figure}

    \vspace*{1cm}
    \begin{figure}
        \begin{center}
            \pstree[nodesepB=5pt]{\Tdot[tnpos=a]~{\vscm{(1 (2 (3 4)))}}}{%
            \TR[tnpos=b]{1}%
            \pstree{\Tdot[tnpos=r]~{\vscm{(2 (3 4))}}}{%
            \TR[tnpos=b]{2}%
            \pstree{\Tdot[tnpos=r]~{\vscm{(3 4)}}}{%
            \TR[tnpos=b]{3}\TR[tnpos=b]{4}}}}
        \end{center}
        \caption{Tree representation of \vscm{(1 (2 (3 4)))}.}
    \end{figure}
\end{exe}

\begin{exe}[2.25]
    If we call the three lists $x$, $y$ and $z$ respectively, the combinations 
    \vscm{(car (cdr (car (cdr (cdr x)))))}, \vscm{(car (car y))} (which can be 
    shortened to \vscm{(caar y)}), and\linebreak
    \vscm{(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr z))))))))))))}
    or, more simply,
    \vscm{(cadr (cadr (cadr (cadr (cadr (cadr z))))))},
    all pick 7 from the lists.
\end{exe}

\begin{exe}[2.26]
    The results printed by the interpreter are \vscm{(1 2 3 4 5 6)} for
    \vscm{(append x y)}, \vscm{((1 2 3) 4 5 6)} for \vscm{(cons x y)} and
    \vscm{((1 2 3) (4 5 6))} for \vscm{(list x y)}.
\end{exe}

\begin{exe}[2.27]
    Here is a possible solution for \vscm{deep-reverse}:
    \scm{ch2/2.27.scm}
\end{exe}

\begin{exe}[2.28]
    A possible solution for \vscm{fringe} is:
    \scm{ch2/2.28.scm}
\end{exe}

\begin{exe}[2.29]
    \ \vspace{-20pt}
    \begin{itemize}
        \item[a.] The selectors can be defined as:
            \scm{ch2/2.29a.scm}
        \item[b.] The total weight can be computed with:
            \scm{ch2/2.29b.scm}
        \item[c.] Since we defined a \vscm{branch-weight} procedure in b., 
            \vscm{balanced?} can be defined simply with:
            \scm{ch2/2.29c.scm}
        \item[d.] To convert to the new representation, the only things that 
            need to be changed are the \vscm{right-branch} and 
            \vscm{branch-structure} selectors:
            \scm{ch2/2.29d.scm}
    \end{itemize}
\end{exe}

\begin{exe}[2.30]
    The two \vscm{square-list} procedures are identical to the \vscm{scale-tree} 
    procedures defined in the text, except that there is only one argument and 
    \vscm{(* tree factor)} is replaced with \vscm{(square tree)}.

    Direct definiton:
    \scm{ch2/2.30a.scm}

    Using \vscm{map} and recursion:
    \scm{ch2/2.30b.scm}
\end{exe}

\begin{exe}[2.31]
    The procedure \vscm{tree-map} can be defined without using \vscm{map}:
    \scm{ch2/2.31a.scm}
    or using it:
    \scm{ch2/2.31b.scm}
\end{exe}

\begin{exe}[2.32]
    The completed procedure is:
    \scm{ch2/2.32.scm}

    The empty set has only one subset: the empty set.

    For a non-empty (finite) set, with elements $\{a_1, …, a_n\}$, the set of 
    subsets is the reunion of the subsets not containing $a_1$ and the subsets 
    containing $a_1$, and the application $S \mapsto S \cup \{a_1\}$ is 
    a bijection between these two sets.
\end{exe}

\subsection{Sequences as Conventional Interfaces}

\begin{exe}[2.33]
    The operations can be redefined as:
    \scm{ch2/2.33.scm}
\end{exe}

\begin{exe}[2.34]
    A polynomial can be evaluated using Horner’s rule with the procedure:
    \scm{ch2/2.34.scm}
\end{exe}

\begin{exe}[2.35]
    This can be done with or without \vscm{enumate-tree}. Without that function:
    \scm{ch2/2.35.scm}
    The mapped function associates to each subtree its number of leaves: 1 if 
    the subtree has no children, i.e.\ is a leaf, \vscm{(count-leaves subtree)} 
    otherwise.
\end{exe}

\begin{exe}[2.36]
    The procedure \vscm{accumulate-n} can be defined as:
    \scm{ch2/2.36.scm}
\end{exe}

\begin{exe}[2.37]
    The matrix operation can be define as:
    \scm{ch2/2.37.scm}
\end{exe}

\begin{exe}[2.38]
    The value of \vscm{(fold-right / 1 (list 1 2 3))} is $\sfrac{3}{2}$.

    The value of \vscm{(fold-left / 1 (list 1 2 3))} is $\sfrac{1}{6}$.

    The value of \vscm{(fold-right list nil (list 1 2 3))} is the list
    \vscm{(1 (2 (3 nil)))}.

    The value of \vscm{(fold-left list nil (list 1 2 p))} is the list
    \vscm{(((nil 1) 2) 3)}.

    \vscm{fold-right} and \vscm{fold-left} produce the same values for any 
    sequence  if (and only if) \vscm{op} is commutative.

    \begin{proof}
        Suppose \vscm{op} commutative. We’ll show by induction that 
        \vscm{fold-left} and \vscm{fold-right} always produce the same results.

        \vscm{(fold-right op init nil)} and
        \vscm{(fold-left op init nil)} both produce \vscm{init}.

        Let’s assume that \vscm{fold-left} and \vscm{fold-right} produce the 
        same values for any list of length $n \geq 0$. If \vscm{sequence} is 
        a list of length $n + 1$,
        \vscm{(fold-right op init sequence)} equals\linebreak
        \vscm{(op (car sequence) (fold-right op init (cdr sequence)))}, and
        \vscm{(fold-left op init sequence)} equals
        \vscm{(op (fold-left op init (cdr sequence)) (car sequence))}. It 
        follows from the induction hypothesis and the commutativity of \vscm{op} 
        that these two values are equal.

        Hence, by induction, \vscm{fold-left} and \vscm{fold-right} always 
        produce the same results.

        Conversely, if \vscm{op} is not commutative, there exists elements 
        \vscm{a} and \vscm{b} such that \vscm{(op a b)} is different from
        \vscm{(op b a)}, and these expressions are equal respectively to
        \vscm{(fold-left op a (list b))} and to
        \vscm{(fold-right op a (list b))}, so \vscm{fold-left} and 
        \vscm{fold-right} don’t always produce the same values.
    \end{proof}
\end{exe}

\begin{exe}[2.39]
    The procedure \vscm{reverse} can be defined in terms of \vscm{fold-left} and 
    \vscm{fold-right} as:
    \scm{ch2/2.39.scm}
\end{exe}

\begin{exe}[2.40]
    The procedure \vscm{unique-pairs} and the simplified definition of 
    \vscm{prime-sum-pairs} are:
    \scm{ch2/2.40.scm}
\end{exe}

\begin{exe}[2.41]
    A solution using \vscm{unique-pairs} from the previous exercise:
    \scm{ch2/2.41.scm}
    The triples $(i, j, k)$ are in decreasing order because \vscm{unique-pairs} 
    returns pairs $(j, k)$ with $j > k$.
\end{exe}

\begin{exe}[2.42]
    A possible solution, with a position represented as the list of the numbers 
    of the lines occupied by the queen in each column. The position of the queen 
    in the first column is at the end of the list because the functions are 
    easier to write this way. I removed the \vscm{k} parameter in \vscm{safe?} 
    and \vscm{adjoin-position} because I didn’t need it.
    \scm{ch2/2.42.scm}
\end{exe}
