\chapter{Building Abstractions with Procedures}

\section{The Elements of Programming}

\begin{exe} % 1.1
    Check with a scheme interpreter.
\end{exe}

\begin{exe} % 1.2
    A minimally indented version:
    \scm{ch01/1.02a.scm}
    A heavily indented version:
    \scm{ch01/1.02b.scm}
\end{exe}

\begin{exe} % 1.3
    \ \vspace{-20pt}
    \scm{ch01/1.03.scm}
\end{exe}

\begin{exe} % 1.4
    If $b > 0$, \vscm{(a-plus-abs-b a b)} returns $a + b$; otherwise it returns 
    $a - b$. In other words, \vscm{(a-plus-abs-b a b)} returns $a + |b|$.
\end{exe}

\begin{exe} % 1.5
    With applicative-order evaluation, the interpreter tries to evaluate 
    \vscm{(p)}, which results in an infinite loop, so the interpreter never 
    returns (or returns an error).

    With normal-order evaluation, the interpreter doesn't try to evaluate 
    \vscm{(p)} until it's really needed, but that never happens since
    \vscm{(= x 0)} returns true, so the call returns 0.
\end{exe}

\begin{exe} % 1.6
    When Alyssa attempts to use this to compute square roots, the program never 
    returns.

    Explication: \vscm{new-if} is an ordinary procedure, so each time it is 
    called, the evaluator tries to evaluate all of its arguments. In particular, 
    each call to \vscm{sqrt-iter} will cause one more call to \vscm{sqrt-iter}, 
    whether \vscm{(good-enough? guess x)} returns true or not, so the evaluator 
    ends up in an infinite loop.
\end{exe}

\begin{exe} % 1.7
    A possible solution:
    \scm{ch01/1.07.scm}

    Let's call $x$ the number whose root we want to compute.

    With the initial \vscm{good-enough?} test:
    \begin{itemize}
        \item If $x$ is very small, the difference between the guess and $x$ 
        becomes smaller than $0.001$ (or any number we would replace $0.001$ 
        with, for small enough numbers) while the guess is still several times 
        larger than $\sqrt{x}$, or even orders of magnitude away from it.
        \begin{example}
            \vscm{(sqrt 0.0001)} returns $0.03230844833048122$ instead of $0.01$ 
            because\linebreak
            \vscm{(abs (- (square 0.03230844833048122) 0.0001))} 
            returns\linebreak
            $9.438358335233747e-4$.
        \end{example}
    \item If $x$ is very large, the difference between the guess and $x$ will 
        always be found to be larger than $0.001$ (or any number we would 
        replace $0.001$ with, for large enough numbers) because
        ($x - \text{any number}$) can not be expressed to the precision required 
        to compare it to $0.001$, so the call never returns.
        \begin{example}
            \vscm{(sqrt 1e+129)} does not return, while \vscm{(sqrt 1e+128)} 
            returns a correct answer almost instantly\footnote{These values are 
            implementation-dependent.}.
        \end{example}
    \end{itemize}

    With the modified versions of \vscm{good-enough?} and \vscm{sqrt-iter}, the 
    above examples work.
\end{exe}

\begin{exe} % 1.8
    Here is a solution based on the solution of exercise 1.7.
    \scm{ch01/1.08.scm}
\end{exe}

\section{Procedures and the Processes They Generate}

\begin{exe} % 1.9
    With the first procedure:
    \scm{ch01/1.09a.scm}

    With the second procedure:
    \scm{ch01/1.09b.scm}

    The first process is recursive, the second is iterative.
\end{exe}

\begin{exe} % 1.10
    Using the interpreter, we obtain $1024 = 2^{10}$ for \vscm{(A 1 10)}, and 
    $65536 = 2^{16}$ for \vscm{(A 2 4)} and \vscm{(A 3 3)}.

    By definition of the Ackermann function, \vscm{(A 0 n)}, i.e.
    \vscm{(f n)} computes $2n$.

    \medskip

    If $n > 0$, \vscm{(g n)} computes $2^n$.

    \begin{proof}
        By definition, \vscm{(g 1)} equals $2$, and for $n > 1$, \vscm{(A 1 n)} 
        equals \vscm{(A 0 (A 1 (- n 1)))}. Since \vscm{(A 0 n)} computes $2n$,
        the result follows by mathematical induction.
    \end{proof}

    \medskip

    If $n > 0$, \vscm{(h n)} computes $2 \uparrow \uparrow n$, that is, 
    $2^{2^{2^{…}}}$ with $n$ copies of $2$.

    \begin{proof}
        This is true for $n = 1$ by definition. For $n > 1$, \vscm{(A 2 n)} is 
        equal to\linebreak
        \vscm{(A 1 (A 2 (- n 1)))}. The result follows by mathematical induction 
        using the previous result.
    \end{proof}

    \medskip

    \begin{remark}
        \vscm{(A 3 3)} returns $2^{16} = 2^{2^{2^2}}$ as well. The recursion 
        beginning with \vscm{(A 3 n)} with\linebreak
        $n > 1$ gives \vscm{(A 2 (A 3 (- n 1)))}, so according to the previous 
        result, \vscm{(A 3 n)} is obtained from \vscm{(A 3 (- n 1))} by 
        computing $2^{2^{2^{…}}}$ with a tower of
        \vscm{(A 3 (- n 1))} 2s, so since \vscm{(A 3 1)} is $2$, \vscm{(A 3 2)} 
        is $2^2 = 4$, and \vscm{(A 3 3)} is $2^{2^{2^2}}$. The general value of 
        \vscm{(A 3 n)} can be noted $2 \uparrow \uparrow \uparrow n$, or $2 
        \uparrow^3 n$.

        This notation can be extended for all $m$s, so \vscm{(A m n)} computes 
        $2 \uparrow^m n$.
    \end{remark}
\end{exe}

\begin{exe} % 1.11
    Procedure computing $f$ by means of a recursive process :
    \scm{ch01/1.11a.scm}
    Procedure computing $f$ by means of a iterative process :
    \scm{ch01/1.11b.scm}
\end{exe}

\begin{exe} % 1.12
    Here is an example of a solution :
    \scm{ch01/1.12.scm}
    The argument $n$ is the line number from the top starting from $0$, and 
    $k$ is the column number from the left starting from $0$.
\end{exe}

% vim:filetype=tex:set expandtab
