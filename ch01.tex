\chapter{Building Abstractions with Procedures}

\section{The Elements of Programming}

\begin{exe} % 1.1
    Check with a scheme interpreter.
\end{exe}

\begin{exe} % 1.2
    A minimally indented version:
    \scm{ch01/1.02a.scm}
    A heavily indented version:
    \scm{ch01/1.02b.scm}
\end{exe}

\begin{exe} % 1.3
    \ \vspace{-20pt}
    \scm{ch01/1.03.scm}
\end{exe}

\begin{exe} % 1.4
    If $b > 0$, \vscm{(a-plus-abs-b a b)} returns $a + b$; otherwise it returns 
    $a - b$. In other words, \vscm{(a-plus-abs-b a b)} returns $a + |b|$.
\end{exe}

\begin{exe} % 1.5
    With applicative-order evaluation, the interpreter tries to evaluate 
    \vscm{(p)}, which results in an infinite loop, so the interpreter never 
    returns (or returns an error).

    With normal-order evaluation, the interpreter doesn't try to evaluate 
    \vscm{(p)} until it's really needed, but that never happens since
    \vscm{(= x 0)} returns true, so the call returns 0.
\end{exe}

\begin{exe} % 1.6
    When Alyssa attempts to use this to compute square roots, the program never 
    returns.

    Explication: \vscm{new-if} is an ordinary procedure, so each time it is 
    called, the evaluator tries to evaluate all of its arguments. In particular, 
    each call to \vscm{sqrt-iter} will cause one more call to \vscm{sqrt-iter}, 
    whether \vscm{(good-enough? guess x)} returns true or not, so the evaluator 
    ends up in an infinite loop.
\end{exe}

\begin{exe} % 1.7
    A possible solution:
    \scm{ch01/1.07.scm}

    Let's call $x$ the number whose root we want to compute.

    With the initial \vscm{good-enough?} test:
    \begin{itemize}
        \item If $x$ is very small, the difference between the guess and $x$ 
        becomes smaller than $0.001$ (or any number we would replace $0.001$ 
        with, for small enough numbers) while the guess is still several times 
        larger than $\sqrt{x}$, or even orders of magnitude away from it.
        \begin{example}
            \vscm{(sqrt 0.0001)} returns $0.03230844833048122$ instead of $0.01$ 
            because\linebreak
            \vscm{(abs (- (square 0.03230844833048122) 0.0001))} 
            returns\linebreak
            $9.438358335233747e-4$.
        \end{example}
    \item If $x$ is very large, the difference between the guess and $x$ will 
        always be found to be larger than $0.001$ (or any number we would 
        replace $0.001$ with, for large enough numbers) because
        ($x - \text{any number}$) can not be expressed to the precision required 
        to compare it to $0.001$, so the call never returns.
        \begin{example}
            \vscm{(sqrt 1e+129)} does not return, while \vscm{(sqrt 1e+128)} 
            returns a correct answer almost instantly\footnote{These values are 
            implementation-dependent.}.
        \end{example}
    \end{itemize}

    With the modified versions of \vscm{good-enough?} and \vscm{sqrt-iter}, the 
    above examples work.
\end{exe}

\begin{exe} % 1.8
    Here is a solution based on the solution of exercise 1.7.
    \scm{ch01/1.08.scm}
\end{exe}

\section{Procedures and the Processes They Generate}

\begin{exe} % 1.9
    With the first procedure:
    \scm{ch01/1.09a.scm}

    With the second procedure:
    \scm{ch01/1.09b.scm}

    The first process is recursive, the second is iterative.
\end{exe}

\begin{exe} % 1.10
    Using the interpreter, we obtain $1024 = 2^{10}$ for \vscm{(A 1 10)}, and 
    $65536 = 2^{16}$ for \vscm{(A 2 4)} and \vscm{(A 3 3)}.

    By definition of the Ackermann function, \vscm{(A 0 n)}, i.e.
    \vscm{(f n)} computes $2n$.

    \medskip

    If $n > 0$, \vscm{(g n)} computes $2^n$.

    \begin{proof}
        By definition, \vscm{(g 1)} equals $2$, and for $n > 1$, \vscm{(A 1 n)} 
        equals \vscm{(A 0 (A 1 (- n 1)))}. Since \vscm{(A 0 n)} computes $2n$,
        the result follows by mathematical induction.
    \end{proof}

    \medskip

    If $n > 0$, \vscm{(h n)} computes $2 \uparrow \uparrow n$, that is, 
    $2^{2^{2^{…}}}$ with $n$ copies of $2$.

    \begin{proof}
        This is true for $n = 1$ by definition. For $n > 1$, \vscm{(A 2 n)} is 
        equal to\linebreak
        \vscm{(A 1 (A 2 (- n 1)))}. The result follows by mathematical induction 
        using the previous result.
    \end{proof}

    \medskip

    \begin{remark}
        \vscm{(A 3 3)} returns $2^{16} = 2^{2^{2^2}}$ as well. The recursion 
        beginning with \vscm{(A 3 n)} with\linebreak
        $n > 1$ gives \vscm{(A 2 (A 3 (- n 1)))}, so according to the previous 
        result, \vscm{(A 3 n)} is obtained from \vscm{(A 3 (- n 1))} by 
        computing $2^{2^{2^{…}}}$ with a tower of
        \vscm{(A 3 (- n 1))} 2s, so since \vscm{(A 3 1)} is $2$, \vscm{(A 3 2)} 
        is $2^2 = 4$, and \vscm{(A 3 3)} is $2^{2^{2^2}}$. The general value of 
        \vscm{(A 3 n)} can be noted $2 \uparrow \uparrow \uparrow n$, or $2 
        \uparrow^3 n$.

        This notation can be extended for all $m$s, so \vscm{(A m n)} computes 
        $2 \uparrow^m n$.
    \end{remark}
\end{exe}

\begin{exe} % 1.11
    Procedure computing $f$ by means of a recursive process :
    \scm{ch01/1.11a.scm}
    Procedure computing $f$ by means of a iterative process :
    \scm{ch01/1.11b.scm}
\end{exe}

\begin{exe} % 1.12
    Here is an example of a solution :
    \scm{ch01/1.12.scm}
    The argument $n$ is the line number from the top starting from $0$, and 
    $k$ is the column number from the left starting from $0$.
\end{exe}

\begin{exe} % 1.13
    Let’s prove that for any $n \geq 0$, $\text{Fib}(n) = \sfrac{\left( \phi^n 
    - \psi^n \right)}{\sqrt{5}}$, where $\phi = \sfrac{\left( 1 + \sqrt{5} 
    \right)}{2}$ and $\psi = \sfrac{\left( 1 - \sqrt{5} \right)}{2}$.

    It’s true for $n = 0$ and $n = 1$.

    Let’s assume that it’s true for any $k < n$. We have :

    \begin{align*}
        \text{Fib}(n) &= \text{Fib}(n - 1) + \text{Fib}(n - 2) \\
        &= \frac{\phi^{n - 1} - \psi^{n - 1}}{\sqrt{5}} + \frac{\phi^{n - 2} 
        - \psi^{n - 2}}{\sqrt{5}} \\
        &= \frac{1}{\sqrt{5}}\left(\phi^{n - 2}\left(\phi + 1\right) - \psi^{n 
        - 2}\left(\psi + 1\right) \right) \\
    \end{align*}

    But $\phi$ and $\psi$ are the roots of the equation $x^2 - x - 1 = 0$, in 
    other words, $\phi^2 = \phi + 1$ and $\psi^2 = \psi + 1$, hence 
    $\text{Fib}(n) = \sfrac{\left(\phi^n - \psi^n \right)}{\sqrt{5}}$.

    Furthermore, $ \lvert 1 - \sqrt{5} \rvert < 2 $, so for any $n \geq 0$, 
    $ \lvert 1 - \sqrt{5} \rvert^n < 2^n $, so dividing by $2^n$, we get 
    $ \lvert \psi^n \rvert < 1 $, and by dividing by $\sqrt{5}$, $ \lvert 
    \sfrac{\psi^n}{\sqrt{5}} \rvert < \sfrac{1}{\sqrt{5}} $. Since 
    $ \sfrac{1}{\sqrt{5}} < \sfrac{1}{2} $, we have $ \lvert 
    \sfrac{\psi^n}{\sqrt{5}} \rvert < \sfrac{1}{2} $ for any $n \geq 0$, which 
    means that $\text{Fib}(n)$ is the closest integer to $\sfrac{\phi^n}{5}$.

\end{exe}

\begin{exe} % 1.14
    The space required is proportional to the maximum depth of the tree, so it 
    grows as $\Theta(n)$.

    For the time complexity, let’s use the mathematical notation $\text{cc}(n, 
    k)$ rather than \vscm{(cc n k)}.

    The time complexity for $\text{cc}(n, 1)$ grows as $\Theta(n)$.

    If we note $v$ the denomination of the $k$-th coin, we have:
    \begin{align*}
        \text{cc}(n, k) &= \text{cc}(n - v, k) + \text{cc}(n, k - 1) \\
                        &= \text{cc}(n - 2v, k) + 2\, \text{cc}(n, k - 1) \\
                        &= … \\
                        &= \text{cc}(n - \left\lceil \frac{n}{v} \right\rceil v, 
                        k) + \left\lceil \frac{n}{v} \right\rceil \text{cc}(n, 
                        k - 1)
    \end{align*}

    Since $n - \left\lceil \frac{n}{v} \right\rceil v \leq 0$, the time 
    complexity of $\text{cc}(n, k)$ is proportional to $n$ times the time 
    complexity of $\text{cc}(n, k - 1)$. As a consequence, the time complexity 
    for $5$ kinds of coins grows as $\Theta(n^5)$.
\end{exe}

\begin{exe} % 1.15
    \ \vspace{-20pt}
    \begin{itemize}
        \item[a.] If the argument is greater than $0.1$, \vscm{p} is called 
            once, and the argument is divided by three. So the number of steps 
            required is the smallest integer $n$ such that $\sfrac{12.15}{3^n} 
            < 0.1$, or equivalently $121.5 < 3^n$. The smallest such $n$ is 5, 
            so \vscm{p} is called 5 times when \vscm{(sine 12.15)} is evaluated.
        \item[b.] By the same calculation as above, if $a > 0.1$, the number of 
            steps is the smallest $n$ such that $10 \, a < 3^n$. By taking the 
            logarithm, we get $\log(10) + \log(a) < n \log(3)$, so $n 
            = \left\lceil \sfrac{(\log(10) + \log(a))}{\log(3)} \right\rceil$.

            Therefore, the number of steps has order of growth 
            $\Theta(\log(n))$. The space required is proportional to the number 
            of steps, so its order of growth is the same.
    \end{itemize}
\end{exe}

\begin{exe} % 1.16
    A possible solution to compute exponentials in a logarithmic number of steps 
    iteratively:
    \scm{ch01/1.16.scm}
\end{exe}

\begin{exe} % 1.17
    A recursive process that multiplies two non-negative integers using 
    a logarithmic number of steps.
    \scm{ch01/1.17.scm}
\end{exe}

% vim:filetype=tex:set expandtab
