\chapter{Modularity, Objects, and State}

\section{Assignment and Local State}

\subsection{Local State Variables}

\begin{exe}[3.1]
    The procedure \vscm{make-accumulator} can be written:
    \scm{ch3/3.01.scm}
\end{exe}

\begin{exe}[3.2]
    The \vscm{make-monitored} procedure can be written:
    \scm{ch3/3.02.scm}
\end{exe}

\begin{exe}[3.3]
    The \vscm{make-account} procedure can be modified in the following way:
    \scm{ch3/3.03.scm}
\end{exe}

\begin{exe}[3.4]
    The procedure can be rewritten as:
    \scm{ch3/3.04.scm}
\end{exe}

\subsection{The Benefits of Introducing Assignment}

\begin{exe}[3.5]
    Using Gambit Scheme’s \vscm{random-real} procedure, that generates a random 
    real number between 0 and 1, \vscm{random-in-range} and the other procedures 
    can be written:
    \scm{ch3/3.05.scm}
\end{exe}

\begin{exe}[3.6]
    The \vscm{rand} procedure can be rewritten as:
    \scm{ch3/3.06.scm}
\end{exe}

\subsection{The Costs of Introducing Assignment}

\begin{exe}[3.7]
    I simply added a \vscm{join} action to the account returned by 
    \vscm{make-account} that creates an access with another password. I also 
    make \vscm{incorrect-password} throw an error instead of simply returning 
    a string, otherwise a call such as
    \vscm{(define new-acc (make-join account curr-pass new-pass))} with an 
    incorrect current password will affect a string value to \vscm{new-acc} 
    without reporting an error, and subsequent uses of the account will throw 
    errors because \vscm{"Incorrect password"} is not a procedure.
    \scm{ch3/3.07.scm}
\end{exe}

\begin{exe}[3.8]
    The procedure \vscm{f} returns:
    \begin{itemize}
        \item 0 if it is the first time it is called;
        \item the previous argument it was called with otherwise.
    \end{itemize}
    Thus, if we evaluate \vscm{(f 0)}, then \vscm{(f 1)}, we get 0 both times, 
    but if we evaluate \vscm{(f 1)}, then \vscm{(f 0)}, we get 0 the first 
    time and 1 the second.
    \scm{ch3/3.08.scm}
\end{exe}

\section{The Environment Model of Evaluation}

\subsection{The Rules for Evaluation}

This subsection contains no exercises.

\subsection{Applying Simple Procedures}

\var{\nametoenv}{4mm}
\var{\envtonext}{3mm}
\begin{exe}[3.9]
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \node[text width=1cm, align=right] (ge) {global\\ env};
            \node[global env, right=\nametoenv of ge] (g) {factorial};
            \node[text width=1cm, align=right, below=of ge] (e1) {E1};
            \node[env, right=\nametoenv of e1] (n1) {n:\,6};
            \node[right=\envtonext of n1] (e2) {E2};
            \node[env, right=\nametoenv of e2] (n2) {n:\,5};
            \node[right=\envtonext of n2] (e3) {E3};
            \node[env, right=\nametoenv of e3] (n3) {n:\,4};
            \node[right=\envtonext of n3] (e4) {E4};
            \node[env, right=\nametoenv of e4] (n4) {n:\,3};
            \node[right=\envtonext of n4] (e5) {E5};
            \node[env, right=\nametoenv of e5] (n5) {n:\,2};
            \node[right=\envtonext of n5] (e6) {E6};
            \node[env, right=\nametoenv of e6] (n6) {n:\,1};

            \draw[->] (ge) -- (ge.west -| g.west);
            \foreach \i in {1, ..., 6} {
                \draw[->] (e\i) -- (n\i);
                \draw[->] (n\i.north) -- (n\i.north|-g.south);
                \node[code,below=2mm of n\i] { \vscm{(if ...)} };
            }
        \end{tikzpicture}
        \caption{Environments created by evaluating \vscm{(factorial 6)} with 
        the recursive procedure. In all the environments created, the code to 
        evaluate corresponds to the body of the \vscm{factorial} procedure.}
        \label{fact_rec}
    \end{figure}

    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \node[text width=1cm, align=right] (ge) {global\\ env};
            \node[global env, right=\nametoenv of ge] (g)
            {factorial\\ fact-iter};
            \node[text width=1cm, align=right, below=of ge] (e1) {E1};
            \node[env, right=\nametoenv of e1] (n1) {n:\,6};
            \node[right=\envtonext of n1] (e2) {E2};
            \node[env, right=\nametoenv of e2] (n2) {p:\,1\\ c:\,1\\ m:\,6};
            \node[right=\envtonext of n2] (e3) {E3};
            \node[env, right=\nametoenv of e3] (n3) {p:\,2\\ c:\,2\\ m:\,6};
            \node[right=(\envtonext+.6cm) of n3] (e4) {E4};
            \node[env, right=\nametoenv of e4] (n4) {p:\,6\\ c:\,3\\ m:\,6};
            \node[right=(\envtonext+.3cm) of n4] (e5) {E5};
            \node[env, right=\nametoenv of e5] (n5) {p:\,24\\ c:\,4\\ m:\,6};
            \node[below=1.9cm of n3] (e6) {E6};
            \node[env, right=\nametoenv of e6] (n6) {p:\,24\\ c:\,5\\ m:\,6};
            \node[right=\envtonext of n6] (e7) {E7};
            \node[env, right=\nametoenv of e7] (n7) {p:\,120\\ c:\,6\\ m:\,6};
            \node[right=\envtonext of n7] (e8) {E8};
            \node[env, right=\nametoenv of e8] (n8) {p:\,720\\ c:\,7\\ m:\,6};

            \draw[->] (ge) -- (ge.west -| g.west);
            \foreach \i in {1, ..., 8} {
                \draw[->] (e\i) -- (n\i);
                \draw[->] (n\i.north) -- (n\i.north|-g.south);
            }

            \node[code, below = 2mm of n1] { \vscm{(fact-iter 1 1 n)} };
            \foreach \i in {2, ..., 8} {
                \node[code, below = 2mm of n\i] { \vscm{(if ...)} };
            }
        \end{tikzpicture}
        \caption{Environments created by evaluating \vscm{(factorial 6)} with 
        the iterative procedure. In environments E2 to E8, the code to evaluate 
        corresponds to the body of the \vscm{fact-iter} procedure.}
        \label{fact_iter}
    \end{figure}

    The environment structure created by evaluating \vscm{(factorial 6)} with 
    both versions of the procedure are shown in figures \ref{fact_rec} and 
    \ref{fact_iter}.
\end{exe}

\subsection{Frames as the Repository of Local State}

\begin{exe}[3.10]
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \matrix[matrix anchor=north west, column sep=2\nametoenv, column 
            2/.style={anchor=base west}] at (0,0) {
            \node[text width=1cm, align=right] (ge) {global\\ env}; &
            \node[code] (mkw) {make-withdraw: ...}; \\[-8pt]
            & \node[code] (w1) {W1: }; \\
            };
            \begin{scope}[on background layer]
                \coordinate (w1b) at ($ (w1.south) - (0, 10pt) $);
                \node[global env, fit=(mkw) (w1b), right=\nametoenv of ge] (g) 
                {};
            \end{scope}
            \node[text width=1cm, align=right, below=of g] (e1) {E1};
            \node[env, right=\nametoenv of e1] (n1) {initial-amount:\,100};
            \node[env, below=of n1] (n2) {balance:\,100};
            \node[left=\nametoenv of n2] (e2) {E2};
            \node[env, below=of n2] (n3) {amount:\,50};

            \coordinate[left=3cm of e1] (p1);
            \procedure{p1}{c1}{c2}
            \node[code, below=of p1] (code) {
            parameters: amount\\
            body: (if ...)
            };
            \node[code, below=1ex of n3] { (if ...) };

            \draw[->] (c1) -- (c1 |- code.north);
            \draw[->] (c2) -- ++(0, -8mm) -| ($ (n2.north) - (.5cm, 0) $);

            \draw[->] (ge) -- (ge.west -| g.west);
            \foreach \i in {1, 2}
                \draw[->] (e\i) -- (n\i);
            \draw[->] (n1.north) -- (n1.north |- g.south);
            \draw[->] (n2) -- (n1);
            \draw[->] (n3) -- (n2);
            \draw[->] (w1) -| ($ (p1) + (0, \circleradius) $);
        \end{tikzpicture}
        \caption{Environments created when executing
        \vscm{(W1 50)} after executing
        \vscm{(define (W1 (make-withdraw 100))}. The environment E1 is created 
        by the call to \vscm{make-withdraw}, E2 is created when the lambda 
        procedure created by the \vscm{let} is executed. E2 is referenced by the 
        procedure returned by \vscm{make-withdraw}. When \vscm{(W1 50)} is 
        called, a new environment pointing to E2 is created, in which the body 
        of \vscm{W1} is evaluated.}
        \label{3.10figa}
    \end{figure}

    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \matrix[matrix anchor=north west, column sep=2\nametoenv, column 
            2/.style={anchor=base west}] at (0,0) {
            & \node[code] (mkw) {make-withdraw: ...}; \\
            \node[text width=1cm, align=right] (ge) {global\\ env};& \node[code] 
            (w1) {W1: }; \\[-8pt]
            & \node[code] (w2) {W2: }; \\
            };
            \begin{scope}[on background layer]
                \coordinate (mkwb) at ($ (mkw.north) + (0, 20pt) $);
                \node[global env, fit=(mkwb) (w1), right=\nametoenv of ge] (g) 
            {};
            \end{scope}
            \coordinate (e1pos) at ($ (g.south west)!.65!(g.south east) $);
            \node[text width=1cm, align=right, below=of e1pos] (e1) {E1};
            \node[env, right=\nametoenv of e1] (n1) {initial-amount:\,100};
            \node[env, below=of n1] (n2) {balance:\,50};
            \node[left=\nametoenv of n2] (e2) {E2};

            \coordinate[left=.8cm of e1] (p1);
            \procedure{p1}{c1}{c2}
            \node[code, below=of p1] (code) {
            parameters: amount\\
            body: (if ...)
            };

            \coordinate (e3pos) at (ge |- g.south east);
            \node[text width=1cm, align=right, below=of e3pos] (e3) {E3};
            \node[env, right=\nametoenv of e3] (n3) {initial-amount:\,100};
            \node[env, below=of n3] (n4) {balance:\,100};
            \node[left=\nametoenv of n4] (e4) {E4};

            \draw[->] (c1) -- (c1 |- code.north);
            \draw[->] (c2) -- ++(0, -8mm) -| ($ (n2.north) - (.5cm, 0) $);
            \draw[->] (w1) -| ($ (p1) + (0, \circleradius) $);

            \coordinate[left=2cm of p1] (p2);
            \procedure{p2}{c3}{c4}
            \draw[->] (c3) |- (code.west);
            \draw[->] (c4) -- ++(0, -8mm) -| ($ (n4.north) + (.5cm, 0) $);
            \draw[->] (w2) -| ($ (p2) + (0, \circleradius) $);

            \draw[->] (ge) -- (ge.west -| g.west);
            \foreach \i in {1, ..., 4}
                \draw[->] (e\i) -- (n\i);
            \draw[->] (n1.north) -- (n1.north |- g.south);
            \draw[->] (n3.north) -- (n3.north |- g.south);
            \draw[->] (n2) -- (n1);
            \draw[->] (n4) -- (n3);
        \end{tikzpicture}
        \caption{Environments created after the execution of
        \vscm{(define W1 (make-withdraw 100))}, followed by \vscm{(W1 50)}, then 
        \vscm{(define W2 (make-withdraw 100))}. The call to \vscm{W1} modified 
        the value of \vscm{balance} in E2, but \vscm{W2} uses the \vscm{balance} 
        variable of environment E4.}
        \label{3.10figb}
    \end{figure}

    The environments created after the execution of the three commands are shown 
    in figures \ref{3.10figa} and \ref{3.10figb}, see the captions for some 
    details. As with the first version of \vscm{make-version}, each object 
    created with a call to \vscm{make-version} uses a \vscm{balance} binding 
    situated in an environment specific to the object.

    In the second version, two environments are created instead of one, and the 
    value of \vscm{initial-value} is unchanged.
\end{exe}

\subsection{Internal Definitions}

\begin{exe}[3.11]
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \matrix[matrix anchor=base west, column sep=2\nametoenv, column 
            2/.style={anchor=base west}] at (0,0) {
            \node[text width=1cm, align=right] (ge) {global\\ env};
            & \node[code] (mkw) {make-account: ...}; \\[-8pt]
            & \node[code] (acc) {acc: }; \\
            };
            \coordinate (e1pos) at ($ (g.south west)!.15!(g.south east) $);
            \matrix[matrix anchor=north west, column sep=2\nametoenv,
            below=1mm of e1pos, column 2/.style={anchor=base west}] {
            \node[text width=1cm, align=right] (e1) {E1};
            & \node[code] (balance) { balance: 50}; \\[-11pt]
            & \node[code] { withdraw: ... }; \\
            & \node[code] { deposit: ... }; \\
            & \node[code] (dispatch) { dispatch: }; \\
            };
            \begin{scope}[on background layer]
                \coordinate (accb) at ($ (acc.south) - (0, 20pt) $);
                \node[global env, fit=(mkw) (accb), right=\nametoenv of ge] (g) 
                    {};
                \node[env, minimum width=4cm, fit=(balance) (dispatch), 
                right=\nametoenv of e1, yshift=-3mm] (n1) {};
            \end{scope}

            \coordinate (xp1) at ($ (n1.south)!.50!(n1.south east) $);
            \coordinate[below=of xp1] (p1);
            \procedure{p1}{c1}{c2}
            \node[code, below=of p1] (code) {
            parameters: m\\
            body: (cond ...)
            };

            \draw[->] (c1) -- (c1 |- code.north);
            \draw[->] (c2) -| ($ (n1.south east) - (3mm, 0) $);

            \draw[->] (ge) -- (ge.west -| g.west);
            \draw[->] (e1) -- (e1.east -| n1.west);
            \draw[->] (n1.north) -- (n1.north |- g.south);
            \draw[->] (dispatch) -| ($ (p1) + (0, \circleradius) $);

            \draw[->] (acc) -- ($ (acc) + (1cm, 0) $)
                |- ($ (p1) + (-2\circleradius, 0) $);

            % Evaluation of ((acc 'deposit) 40)
            \coordinate[right=2cm of n1.east] (middle);
            \node[env, above=1em of middle] (m)
            {m: 'deposit};
            \node[env, below=1em of middle] (amount) {amount: 40};
            \node[right=of m] (e2) {E2};
            \node[right=of amount] (e3) {E3};
            \draw[->] (e2) -- (m);
            \draw[->] (e3) -- (amount);
            \draw[->] (m) -- (m -| n1.east);
            \draw[->] (amount) -- (amount -| n1.east);
        \end{tikzpicture}

        \caption{Environments when evaluating \vscm{((acc 'deposit) 40)}
        after evaluating \vscm{(define acc (make-account 50))}. E1 is created 
        when defining \vscm{acc}, then the evaluation of \vscm{(acc 'deposit)}
        causes the creation of an environment referencing E1, and since the 
        result of the evaluation is the procedure \vscm{deposit}, \vscm{(deposit 
        40)} is then evaluated in a new environment.}
        \label{3.11figa}
    \end{figure}

    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \matrix[matrix anchor=base west, column sep=2\nametoenv, column 
            2/.style={anchor=base west}] at (0,0) {
            \node[text width=1cm, align=right] (ge) {global\\ env};
            & \node[code] (mkw) {make-account: ...}; \\[-8pt]
            & \node[code] (acc) {acc: }; \\
            };
            \coordinate (e1pos) at ($ (g.south west)!.15!(g.south east) $);
            \matrix[matrix anchor=north west, column sep=2\nametoenv,
            below=1cm of e1pos, column 2/.style={anchor=base west}] {
            \node[text width=1cm, align=right] (e1) {E1};
            & \node[code] (balance) { balance: 90}; \\[-11pt]
            & \node[code] { withdraw: ... }; \\
            & \node[code] { deposit: ... }; \\
            & \node[code] (dispatch) { dispatch: }; \\
            };
            \begin{scope}[on background layer]
                \coordinate (accb) at ($ (acc.south) - (0, 20pt) $);
                \node[global env, fit=(mkw) (accb), right=\nametoenv of ge] (g) 
                    {};
                \node[env, minimum width=4cm, fit=(balance) (dispatch), 
                right=\nametoenv of e1, yshift=-3mm] (n1) {};
            \end{scope}

            \coordinate (xp1) at ($ (n1.south)!.50!(n1.south east) $);
            \coordinate[below=of xp1] (p1);
            \procedure{p1}{c1}{c2}
            \node[code, below=of p1] (code) {
            parameters: m\\
            body: (cond ...)
            };

            \draw[->] (c1) -- (c1 |- code.north);
            \draw[->] (c2) -| ($ (n1.south east) - (3mm, 0) $);

            \draw[->] (ge) -- (ge.west -| g.west);
            \draw[->] (e1) -- (e1.east -| n1.west);
            \draw[->] (n1.north) -- (n1.north |- g.south);
            \draw[->] (dispatch) -| ($ (p1) + (0, \circleradius) $);

            \draw[->] (acc) -- ($ (acc) + (1cm, 0) $)
                |- ($ (p1) + (-2\circleradius, 0) $);

            % Evaluation of ((acc 'withdraw) 60)
            \coordinate[right=2cm of n1.east] (middle);
            \node[env, above=1em of middle] (m)
            {m: 'withdraw};
            \node[env, below=1em of middle] (amount) {amount: 60};
            \node[right=of m] (e4) {E4};
            \node[right=of amount] (e5) {E5};
            \draw[->] (e4) -- (m);
            \draw[->] (e5) -- (amount);
            \draw[->] (m) -- (m -| n1.east);
            \draw[->] (amount) -- (amount -| n1.east);
        \end{tikzpicture}

        \caption{Environments during the evaluation of
        \vscm{((acc 'withdraw) 60)}.}
        \label{3.11figb}
    \end{figure}

    The environments generated by the evaluation of
    \vscm{(define acc (make-account 50))},\\
    \vscm{((acc 'deposit) 40)} and \vscm{((acc 'withdraw) 60)} are shown in 
    figures \ref{3.11figa} and \ref{3.11figb}. The local state for \vscm{acc} is 
    kept in the local environment referenced by the procedure object referenced 
    by \vscm{acc}.

    If a second environment is created, its local state is kept in a new 
    environment created when evaluating the \vscm{make-account} procedure, so it 
    does not interfere with \vscm{acc}’s local environment.

    The environment structures of \vscm{acc} and \vscm{acc2} share the global 
    environment.
\end{exe}

\section{Modeling with Mutable Data}

\subsection{Mutable List Structure}

\begin{exe}[3.12]
    \begin{figure}
        \centering
        \begin{tikzpicture}[box and pointer]
            \matrix[cell matrix] {
            % x
            \node[struct name] (x) {x}; &[+2\boxsize]
            \node[car] (carx) {}; & \node[cdr] (cdrx) {}; &[+\boxsize]
            \node[car] (cadrx) {}; & \node[cdr] (cddrx) {}; \\

            % Values
            & \node[box] (a) {a}; &&
            \node[box] (b) {b}; &&[+2\boxsize]
            \node[box] (c) {c}; &&[+\boxsize]
            \node[box] (d) {d}; & \\

            % z and y
            \node[struct name] (z) {z}; &[+2\boxsize]
            \node[car] (carz) {}; & \node[cdr] (cdrz) {}; &
            \node[car] (cadrz) {}; & \node[cdr] (cddrz) {}; &
            \node[car] (cary) {}; & \node[cdr] (cdry) {}; &
            \node[car] (cadry) {}; & \node[cdr] (cddry) {}; &
            \\
            };

            \draw[pointer] (x) -- (carx);
            \link{carx}{a}
            \link{cdrx}{cadrx}
            \link{cadrx}{b}
            \nil{cddrx}

            \draw[pointer] (z) -- (carz);
            \link{carz}{a}
            \link{cdrz}{cadrz}
            \link{cadrz}{b}
            \link{cddrz}{cary}
            \link{cary}{c}
            \link{cdry}{cadry}
            \link{cadry}{d}
            \nil{cddry}

            \coordinate(ypos) at ($ (cary.north west)!.4!(cary.west) $);
            \node[struct name, left=1.5\boxsize of ypos] (y) {y};
            \draw[pointer] (y) -- (ypos);
        \end{tikzpicture}
        \caption{The lists \vscm{x}, \vscm{y} and \vscm{z} right after the 
        definition of \vscm{z}.}
        \label{3.12z}
    \end{figure}

    \begin{figure}
        \centering
        \begin{tikzpicture}[box and pointer]
            \matrix[cell matrix] {
            % z and y
            \node[struct name] (x) {x}; &[+2\boxsize]
            \node[car] (carx) {}; & \node[cdr] (cdrx) {}; &[+\boxsize]
            \node[car] (cadrx) {}; & \node[cdr] (cddrx) {}; &[+3\boxsize]
            \node[car] (cary) {}; & \node[cdr] (cdry) {}; &[+\boxsize]
            \node[car] (cadry) {}; & \node[cdr] (cddry) {}; & \\

            % Values
            & \node[box] (a) {a}; &&
            \node[box] (b) {b}; &&[+2\boxsize]
            \node[box] (c) {c}; &&[+\boxsize]
            \node[box] (d) {d}; & \\
            };

            \draw[pointer] (x) -- (carx);
            \link{carx}{a}
            \link{cdrx}{cadrx}
            \link{cadrx}{b}
            \link{cddrx}{cary}

            \link{cary}{c}
            \link{cdry}{cadry}
            \link{cadry}{d}
            \nil{cddry}

            \coordinate(wpos) at ($ (carx.north west)!.4!(carx.west) $);
            \node[struct name, left=3\boxsize of wpos] (w) {w};
            \draw[pointer] (w) -- (wpos);

            \coordinate(ypos) at ($ (cary.north west)!.4!(cary.west) $);
            \node[struct name, left=1.5\boxsize of ypos] (y) {y};
            \draw[pointer] (y) -- (ypos);
        \end{tikzpicture}
        \caption{The lists \vscm{x}, \vscm{y} and \vscm{w} right after the 
        definition of \vscm{w}.}
        \label{3.12w}
    \end{figure}
    The first response is \vscm{(b)}, the second response is \vscm{(b c d)}. The 
    figure \ref{3.12z} shows the lists \vscm{x}, \vscm{y} and \vscm{z} right 
    after the definition of \vscm{z}. The figure \ref{3.12w} shows the lists 
    \vscm{x}, \vscm{y} and \vscm{w} after the definition of \vscm{w}.
\end{exe}

\begin{exe}[3.13]
    \label{3.13}
    \begin{figure}
        \centering
        \begin{tikzpicture}[box and pointer]
            \matrix[cell matrix] {
            \node[car] (carz) {}; & \node[cdr] (cdrz) {}; &[+\boxsize]
            \node[car] (cadrz) {}; & \node[cdr] (cddrz) {}; &[+\boxsize]
            \node[car] (caddrz) {}; & \node[cdr] (cdddrz) {}; \\

            % Values
            \node[box] (a) {a}; &&
            \node[box] (b) {b}; &&[+\boxsize]
            \node[box] (c) {c}; \\
            };

            \link{carz}{a}
            \link{cdrz}{cadrz}
            \link{cadrz}{b}
            \link{cddrz}{caddrz}
            \link{caddrz}{c}

            \coordinate(zpos) at ($ (carz.north west)!.6!(carz.west) $);
            \node[struct name, left=2\boxsize of zpos] (z) {z};
            \draw[pointer] (z) -- (zpos);

            \coordinate(in) at ($ (carz.south west)!.6!(carz.west) $);
            \draw[box pointer] (cdddrz.base) -- ++(0, -3.5\boxsize) -|
                ($ (in) - (\boxsize, 0) $) -- (in);
        \end{tikzpicture}
        \caption{The structure created by
        \vscm{(define z (make-cycle (list 'a 'b 'c))}.}
        \label{3.13fig}
    \end{figure}
    The structure \vscm{z} is shown in figure \ref{3.13fig}.

    If we try to compute \vscm{(last-pair z)}, we get an infinite loop since 
    \vscm{z} has a cycle.
\end{exe}

\begin{exe}[3.14]
    \begin{figure}
        \centering
        \begin{tikzpicture}[box and pointer]
            \matrix[cell matrix] {
            \node[struct name] (v) {v}; &[+2\boxsize]
            \node[car] (c11) {}; & \node[cdr] (c12) {}; &[+\boxsize]
            \node[car] (c21) {}; & \node[cdr] (c22) {}; &[+\boxsize]
            \node[car] (c31) {}; & \node[cdr] (c32) {}; &[+\boxsize]
            \node[car] (c41) {}; & \node[cdr] (c42) {}; & \\

            % Values
            & \node[box] (a) {a}; &&
            \node[box] (b) {b}; &&[+\boxsize]
            \node[box] (c) {c}; &&[+\boxsize]
            \node[box] (d) {d}; & \\
            };

            \draw[pointer] (v) -- (c11);
            \link{c11}{a}
            \link{c12}{c21}
            \link{c21}{b}
            \link{c22}{c31}
            \link{c31}{c}
            \link{c32}{c41}
            \link{c41}{d}
            \nil{c42}
        \end{tikzpicture}
        \caption{The list to which \vscm{v} is bound initially.}
        \label{3.14v}
    \end{figure}

    \begin{figure}
        \centering
        \begin{tikzpicture}[box and pointer]
            \matrix[cell matrix] {
            \node[struct name] (w) {w}; &[+2\boxsize]
            \node[car] (c11) {}; & \node[cdr] (c12) {}; &[+\boxsize]
            \node[car] (c21) {}; & \node[cdr] (c22) {}; &[+\boxsize]
            \node[car] (c31) {}; & \node[cdr] (c32) {}; &[+3\boxsize]
            \node[car] (c41) {}; & \node[cdr] (c42) {}; & \\

            % Values
            & \node[box] (d) {d}; &&
            \node[box] (c) {c}; &&[+\boxsize]
            \node[box] (b) {b}; &&[+3\boxsize]
            \node[box] (a) {a}; & \\
            };

            \draw[pointer] (w) -- (c11);
            \link{c11}{d}
            \link{c12}{c21}
            \link{c21}{c}
            \link{c22}{c31}
            \link{c31}{b}
            \link{c32}{c41}
            \link{c41}{a}
            \nil{c42}

            \coordinate(vpos) at ($ (c41.north west)!.6!(c41.west) $);
            \node[struct name, left=2\boxsize of vpos] (v) {v};
            \draw[pointer] (v) -- (vpos);
        \end{tikzpicture}
        \caption{The lists \vscm{v} and \vscm{w} after calling \vscm{mystery}.}
        \label{3.14w}
    \end{figure}
    The \vscm{mystery} procedure reverses the elements of the list. Figure 
    \ref{3.14v} shows the list \vscm{v} as it is initially, and figure 
    \ref{3.14w} shows the lists \vscm{v} and \vscm{w} after evaluating 
    \vscm{(define w (mystery v))}. The values of \vscm{v} and \vscm{w} would be 
    \vscm{(a)} and \vscm{(d c b a)}.
\end{exe}

\begin{exe}[3.15]
    \begin{figure}
        \centering
        \begin{tikzpicture}[box and pointer]
            \matrix[cell matrix] {
            \node[struct name] (z1) {z1}; &[+2\boxsize]
            \node[car] (c11) {}; & \node[cdr] (c12) {}; \\

            &
            \node[car] (c21) {}; & \node[cdr] (c22) {}; &[+\boxsize]
            \node[car] (c23) {}; & \node[cdr] (c24) {}; \\

            &
            \node[box] (wow) {wow}; &&
            \node[box] (b) {b}; \\
            };

            \draw[pointer] (z1) -- (c11);
            \link{c11}{c21}
            \link{c12}{c22}
            \link{c21}{wow}
            \link{c22}{c23}
            \link{c23}{b}
            \nil{c24}
        \end{tikzpicture}
        \caption{The list \vscm{z1} after applying \vscm{set-to-wow!} to it.}
        \label{3.15z1}
    \end{figure}

    \begin{figure}
        \centering
        \begin{tikzpicture}[box and pointer]
            \matrix[cell matrix] {
            \node[struct name] (z2) {z2}; &[+2\boxsize]
            \node[car] (c11) {}; & \node[cdr] (c12) {}; &[+\boxsize]
            \node[car] (c13) {}; & \node[cdr] (c14) {}; &[+\boxsize]
            \node[car] (c15) {}; & \node[cdr] (c16) {}; \\

            &&&
            \node[box] (a) {a}; &&
            \node[box] (b) {b}; \\

            &&&
            \node[car] (c21) {}; & \node[cdr] (c22) {}; &
            \node[car] (c23) {}; & \node[cdr] (c24) {}; \\

            &&&
            \node[box] (wow) {wow}; \\
            };

            \draw[pointer] (z2) -- (c11);
            \draw[box pointer] (c11.base) |- (c21);
            \link{c12}{c13}
            \link{c13}{a}
            \link{c14}{c15}
            \link{c15}{b}
            \nil{c16}
            \link{c21}{wow}
            \link{c22}{c23}
            \link{c23}{b}
            \nil{c24}
        \end{tikzpicture}
        \caption{The list \vscm{z2} after applying \vscm{set-to-wow!} to it.}
        \label{3.15z2}
    \end{figure}
    The figures \ref{3.15z1} and \ref{3.15z2} show the effect of 
    \vscm{set-to-wow!} on \vscm{z1} and \vscm{z2}.
\end{exe}

\begin{exe}[3.16]
    \begin{figure}
        \centering
        \begin{tikzpicture}[box and pointer,
            every label/.style={font=\sffamily}]
            \hspace{-1.3cm} % To center the figure better.
            % Example returning 3.
            \matrix[cell matrix, label=below:{List structure returning 3.}] (e1) 
            {
            \node[struct name] (x) {x}; &[+\boxsize]
            \node[car] (x11) {}; & \node[cdr] (x12) {}; &[+\boxsize]
            \node[car] (x21) {}; & \node[cdr] (x22) {}; &[+\boxsize]
            \node[car] (x31) {}; & \node[cdr] (x32) {}; \\

            & \node[box] (xa) {a}; &&
            \node[box] (xb) {b}; &&[+\boxsize]
            \node[box] (xc) {c}; \\
            };

            \draw[pointer] (x) -- (x11);
            \link{x11}{xa}
            \link{x12}{x21}
            \link{x21}{xb}
            \link{x22}{x31}
            \link{x31}{xc}
            \nil{x32}

            % Example returning 4.
            \matrix[cell matrix, right=of e1, label=below:{List structure 
            returning 4.}] (e2) {
            \node[struct name] (y) {y}; &[+\boxsize]
            \node[car] (y11) {}; & \node[cdr] (y12) {}; &[+\boxsize]
            \node[car] (y21) {}; & \node[cdr] (y22) {}; &[+\boxsize]
            \node[car] (y31) {}; & \node[cdr] (y32) {}; \\

            &&&
            \node[box] (ya) {a}; &&[+\boxsize]
            \node[box] (yb) {b}; \\
            };

            \draw[pointer] (y) -- (y11);
            \draw[box pointer] (y11.base) -- ++(0, 1.2\boxsize) -| (y31);
            \link{y12}{y21}
            \link{y21}{ya}
            \link{y22}{y31}
            \link{y31}{yb}
            \nil{y32}

            % Example returning 7.
            \matrix[cell matrix, below=4em of e1, label=below:{List structure 
            returning 7.}] (e3) {
            \node[struct name] (z) {z}; &[+\boxsize]
            \node[car] (z11) {}; & \node[cdr] (z12) {}; &[+\boxsize]
            \node[car] (z21) {}; & \node[cdr] (z22) {}; &[+\boxsize]
            \node[car] (z31) {}; & \node[cdr] (z32) {}; \\

            &&&&&
            \node[box] (za) {a}; \\
            };

            \draw[pointer] (z) -- (z11);
            \draw[box pointer] (z11.base) -- ++(0, -1.2\boxsize) -| (z21);
            \link{z12}{z21}
            \draw[box pointer] (z21.base) -- ++(0, 1.2\boxsize) -| (z31);
            \link{z22}{z31}
            \link{z31}{za}
            \nil{z32}

            % Example never returning.
            \matrix[cell matrix, right=of e3, label=below:{List structure never 
            returning.}] (e4) {
            \node[struct name] (t) {t}; &[+\boxsize]
            \node[car] (t11) {}; & \node[cdr] (t12) {}; &[+\boxsize]
            \node[car] (t21) {}; & \node[cdr] (t22) {}; &[+\boxsize]
            \node[car] (t31) {}; & \node[cdr] (t32) {}; \\

            & \node[box] (ta) {a}; &&
            \node[box] (tb) {b}; &&[+\boxsize]
            \node[box] (tc) {c}; \\
            };

            \draw[pointer] (t) -- (t11);
            \link{t11}{ta}
            \link{t12}{t21}
            \link{t21}{tb}
            \link{t22}{t31}
            \link{t31}{tc}
            \draw[box pointer] (t32.base) -- ++(0, 1.2\boxsize) -| (t11);
        \end{tikzpicture}
        \caption{Structures made of exactly three pairs for which Ben’s 
            procedure returns different values.}
        \label{3.16ex}
    \end{figure}
    Figure \ref{3.16ex} shows examples of list structures made up of exactly 
    three pairs for which Ben’s procedure returns 3, 4, 7, or never at all.
    These structures can be defined in the following way, using 
    \vscm{make-cycle} from exercise \ref{3.13} for the last one.
    \scm{ch3/3.16.scm}
\end{exe}

\begin{exe}[3.17]
    A possible solution is:
    \scm{ch3/3.17.scm}
\end{exe}

\begin{exe}[3.18]
    Here is a possible solution:
    \scm{ch3/3.18.scm}
\end{exe}

\begin{exe}[3.19]
    We go through the list with two pointers: one advancing one step at a time, 
    the other advancing two steps at a time. If the list contains a cycle, 
    they’ll end up pointing to the same pair after a while. Otherwise, the 
    second one will reach the end of the list.
    \scm{ch3/3.19.scm}
\end{exe}

\begin{exe}[3.20]
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \matrix[matrix anchor=base west, column sep=2\nametoenv, column 
            2/.style={anchor=base west}] at (0,0) {
            & \node[code] (cons) {cons: ...}; \\[-3pt]
            \node[text width=1cm, align=right] (ge) {global\\ env};
            & \node[code] (z) {z: }; \\[-8pt]
            & \node[code] (x) {x: }; \\
            };

            % E1
            \coordinate (e1pos) at ($ (g.south west)!.10!(g.south east) $);
            \matrix[matrix anchor=north west, column sep=2\nametoenv,
            below=of e1pos, column 2/.style={anchor=base west}] {
            \node[text width=1cm, align=right] (e1) {E1};
            & \node[code] (x1) { x: 1}; \\[-11pt]
            & \node[code] (y1) { y: 2}; \\
            & \node[code] { set-x!: ... }; \\
            & \node[code] { set-y!: ... }; \\
            & \node[code] (dispatch1) { dispatch: }; \\
            };

            % E2
            \coordinate (e2pos) at ($ (g.south west)!.55!(g.south east) $);
            \matrix[matrix anchor=north west, column sep=2\nametoenv,
            below=of e2pos, column 2/.style={anchor=base west}] {
            \node[text width=1cm, align=right] (e2) {E2};
            & \node[code] (x2) { x: x}; \\[-11pt]
            & \node[code] (y2) { y: x}; \\
            & \node[code] { set-x!: ... }; \\
            & \node[code] { set-y!: ... }; \\
            & \node[code] (dispatch2) { dispatch: }; \\
            };

            % Backgrounds
            \begin{scope}[on background layer]
                \node[global env, fit=(cons) (x), right=\nametoenv of ge, 
                yshift=1mm] (g) {};
                \node[env, minimum width=4cm, fit=(x1) (dispatch1), 
                right=\nametoenv of e1, yshift=-6mm] (n1) {};
                \node[env, minimum width=4cm, fit=(x2) (dispatch2), 
                right=\nametoenv of e2, yshift=-6mm] (n2) {};
            \end{scope}

            \coordinate (xp1) at ($ (n1.south)!.50!(n1.south east) $);
            \coordinate[below=of xp1] (p1);
            \procedure{p1}{c1}{c2}
            \node[code, below=of p1] (code) {
            parameters: m\\
            body: (cond ...)
            };

            \coordinate (xp2) at ($ (n2.south)!.50!(n2.south east) $);
            \coordinate[below=of xp2] (p2);
            \procedure{p2}{c3}{c4}

            \draw[->] (c1) -- (c1 |- code.north);
            \draw[->] (c2) -| ($ (n1.south east) - (3mm, 0) $);

            \draw[->] (ge) -- (ge.west -| g.west);
            \draw[->] (e1) -- (e1.east -| n1.west);
            \draw[->] (n1.north) -- (n1.north |- g.south);
            \draw[->] (dispatch1) -| ($ (p1) + (0, \circleradius) $);

            \draw[->] (e2) -- (e2.east -| n2.west);
            \draw[->] (c3) |- (code);
            \draw[->] (c4) -| ($ (n2.south east) - (3mm, 0) $);
            \draw[->] (n2.north) -- (n2.north |- g.south);
            \draw[->] (dispatch2) -| ($ (p2) + (0, \circleradius) $);
            \draw[->] (x) -- ($ (x) + (1cm, 0) $)
                |- ($ (p1) + (-2\circleradius, 0) $);
            \draw[->] (z) -- ($ (z) + (7cm, 0) $)
                |- ($ (p2) + (-2\circleradius, 0) $);
        \end{tikzpicture}
        \caption{Environment structure after the definitions of \vscm{x} and 
        \vscm{z}. In E2, the values of \vscm{x} and \vscm{y} correspond to the 
        \vscm{x} defined in the global environment.}
        \label{3.20fig}
    \end{figure}
    Figure \ref{3.20fig} shows the environments created by the definitions of 
    \vscm{x} and \vscm{z}. When\\
    \vscm{(set-car! (cdr z) 17)} is evaluated, \vscm{(cdr z)} is evaluated 
    first. This creates an environment E3 pointing to E2, where \vscm{(z 'cdr)} 
    is evaluated, returning the \vscm{x} defined in the global environment. So 
    the expression becomes \vscm{(set-car! x 17)}, evaluated in the global 
    environment. The expression
    \vscm{((x 'set-car!) 17)} is then evaluated. The evaluation of
    \vscm{(x 'set-car!)} leads to the creation of an environment E4 pointing to 
    E1, in which the evaluation returns the \vscm{set-x!} procedure from 
    environment E1. The evaluation of the expression obtained \vscm{(set-x! 17)} 
    leads to the modification of the value of \vscm{x} in environment E1. 
    Lastly, \vscm{(car x)} is evaluated in an environment pointing to E1, so the 
    value returned is 17.
\end{exe}

\subsection{Representing Queues}

\begin{exe}[3.21]
    The elements actually contained in the queue are only the contents of the 
    queue’s \vscm{car}. The queue’s \vscm{cdr} points to the last element of the 
    queue, so it is printed twice. The rear pointer is not updated when the last 
    element from the queue is deleted, so the former last element is still 
    printed although the queue is empty.
    \scm{ch3/3.21.scm}
\end{exe}

\begin{exe}[3.22]
    The constructor, selectors and mutators can be defined in the following way. 
    The implementation of the queue operations doesn’t need to be modified.
    \scm{ch3/3.22.scm}
\end{exe}

\begin{exe}[3.23]
    To respect the requirement that all operations should be accomplished in 
    $\Theta(1)$ steps, it’s necessary to use a doubly-linked list instead of 
    a singly-linked list. The deque is represented as a pair containing 
    a pointer to the first element of a list and a pointer to the last element 
    of this list just like the queue. Each element of the list is a pair 
    containing the value and a pointer to the previous element of the list. 
    Since such a structure can’t be printed since it contains infinite loops as 
    soon as the deque contains at least 2 elements, the insertion and deletion 
    procedures return a list representation of the contents of the deque.
    \scm{ch3/3.23.scm}
\end{exe}

\subsection{Representing Tables}

\begin{exe}[3.24]
    The only necessary change is to define an \vscm{assoc} procedure that uses 
    the provided \vscm{same-key?} instead of \vscm{equal?}. The code below is 
    a possible solution for a one-dimensional table. For multi-dimensional 
    tables, there is no reason to assume that the successive keys are of the 
    same type or that the same equality test must be used at every level, so 
    multiple comparison procedures should be provided, and the right procedure 
    should be passed as an argument to \vscm{assoc} at each level of the table.
    \scm{ch3/3.24.scm}
    \scm{ch3/3.24test.scm}
\end{exe}

\begin{exe}[3.25]
    It would be possible to use the lists as keys directly but I don’t think 
    that’s the point of the exercise. The solution I implemented allows 
    different numbers of keys for different records, however it does not allow 
    keys that are prefixes of each other: if a value is stored under the key
    \vscm{'(a b c)} and another value is then stored under \vscm{'(a b)}, the 
    record for \vscm{'(a b c)} is silently deleted, and vice versa. It would 
    also be inefficient for large tables since it checks whether the record 
    found really contains a table by going through the whole record before 
    looking for the following key in it.
    \scm{ch3/3.25.scm}
\end{exe}

\begin{exe}[3.26]
    Here is an example of a one-dimensional table where the keys are ordered 
    with the given comparison procedure \vscm{<?}. The local table is stored as 
    a binary tree of records instead of a headed list. I used mutable trees 
    instead of using the \vscm{adjoin-tree} procedure for binary trees of 
    section \ref{2.3.3} to avoid stacking recursive calls and creating multiple 
    intermediate trees.
    \scm{ch3/3.26.scm}
\end{exe}

\begin{exe}[3.27]
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \matrix[matrix anchor=base west, column sep=2\nametoenv, column 
            2/.style={anchor=base west}] at (0,0) {
            \node[text width=1cm, align=right] (ge) {global\\ env};
            & \node[code] (memoize) {memoize: ...}; \\[-8pt]
            & \node[code] (memo-fib) {memo-fib: }; \\
            };
            \coordinate (e1pos) at ($ (g.south west)!.25!(g.south east) $);
            \matrix[matrix anchor=north west, column sep=2\nametoenv,
            below=1cm of e1pos, column 2/.style={anchor=base west}] {
            \node[text width=1cm, align=right] (e1) {E1};
            & \node[code] (f) { f: ...}; \\[-11pt]
            & \node[code] (table) { table: ... }; \\
            };
            \begin{scope}[on background layer]
                \node[global env, fit=(memoize) (memo-fib),
                right=\nametoenv of ge, yshift=-1mm] (g) {};
                \node[env, minimum width=3cm, fit=(f) (table),
                right=\nametoenv of e1, yshift=1mm] (n1) {};
            \end{scope}

            \coordinate (xp1) at ($ (n1.south west)!.50!(n1.south east) $);
            \coordinate[below=of xp1] (p1);
            \procedure{p1}{c1}{c2}
            \node[code, below=of p1] (code) {
            parameters: x\\
            body: (let ...)
            };

            \draw[->] (c1) -- (c1 |- code.north);
            \draw[->] (c2) -- (c2 |- n1.south);

            \draw[->] (ge) -- (ge.west -| g.west);
            \draw[->] (e1) -- (e1.east -| n1.west);
            \draw[->] (n1.north) -- (n1.north |- g.south);

            \draw[->] (memo-fib) -- ($ (memo-fib) + (2cm, 0) $)
                |- ($ (p1) + (-2\circleradius, 0) $);

            % Evaluation of (memo-fib 3)
            \node[env, right=of n1] (n3) {n: 3};
            \node[below=of n3] {$\vdots$};
            \node[right=of n3] (e4) {E4};
            \draw[->] (e4) -- (n3);
            \draw[->] (n3) -- (n3 -| n1.east);
        \end{tikzpicture}

        \caption{Environments created during the evaluation of
        \vscm{(memo-fib 3)}.}
        \label{3.27fig}
    \end{figure}
    Figure \ref{3.27fig} shows some of the environments created during the 
    evaluation of \vscm{(memo-fib 3)}.
    The call to \vscm{memoize} creates a local environment E1 containing 
    a table, and the procedure returned by \vscm{memoize} points to this 
    environment. When \vscm{memo-fib} is called for the first time with a value, 
    it puts the computed result into the table. When it is called again with the 
    same value, it simply returns the value stored in the table instead of 
    making recursive calls. So \vscm{memo-fib} computes the $n$th Fibonacci 
    number in linear time because it never computes the value for the same 
    number twice.

    If we had defined \vscm{memo-fib} to be \vscm{(memoize fib)}, it would not 
    have worked because \vscm{fib} calls itself rather than \vscm{memo-fib} 
    recursively.
\end{exe}

\subsection{A Simulator for Digital Circuits}

\begin{exe}[3.28]
    Here is a definition of an or-gate similar to the definiton of the and-gate:
    \scm{ch3/3.28.scm}
\end{exe}

\begin{exe}[3.29]
    Using the logical equivalency between $a \lor b$ and $\lnot (\lnot a \land 
    \lnot b)$, we can build an or-gate from and-gates and inverters. The delay 
    for an or-gate built this way is the and-gate delay plus twice the inverter 
    delay.
    \scm{ch3/3.29.scm}
\end{exe}

\begin{exe}[3.30]
    The ripple-carry-adder can be defined using the following procedure:
    \scm{ch3/3.30.scm}

    Let’s use the following notations: $o = \textrm{or-delay}, 
    a = \textrm{and-delay}, i = \textrm{inverter-delay}$.
    Let’s call $R_{Ci}$ the delay to obtain $C_i$ in a ripple-carry adder, 
    $R_{Si}$ the delay to obtain $S_i$ in a ripple-carry adder, $F_s$ the delay 
    to obtain the sum bit in a full-adder, $F_c$ the delay to obtain the carry 
    bit in a full-adder, $H_s$ the delay to obtain the carry in a half-adder, 
    $H_c$ the delay to obtain the carry in a half-adder.

    For the half-adder we have $H_c = a$ and
    $H_s = \max(2a + i, o + a)$.

    For the full-adder, we have $F_s = 2 H_s = 2 \max(2a + i, o + a)$, and $F_c 
    = H_s + H_c + o = a + o + \max(2a + i, o + a)$, from where
    $F_s \geq F_c$.

    For the full-carry adder, we have:
    $R_{Ci} = (n - i) \times F_c$ and $R_{Si} = R_{Ci} + F_s$ because only the 
    carry is transmitted to the following full-adders.

    The delay to obtain the complete output from an $n$-bit ripple-carry adder 
    is $R_{C1} + \max(F_s, F_c) = R_{C1} + F_s = (n - 1) F_c + F_s$. In terms of 
    the delays for and-gates, or-gates and inverters, the delay for the 
    ripple-carry adder is
    $ (n - 1) (a + o) + (n + 1) \max(2a + i, o + a) $.
\end{exe}
