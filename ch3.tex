\chapter{Modularity, Objects, and State}

\section{Assignment and Local State}

\subsection{Local State Variables}

\begin{exe}[3.1]
    The procedure \vscm{make-accumulator} can be written:
    \scm{ch3/3.01.scm}
\end{exe}

\begin{exe}[3.2]
    The \vscm{make-monitored} procedure can be written:
    \scm{ch3/3.02.scm}
\end{exe}

\begin{exe}[3.3]
    The \vscm{make-account} procedure can be modified in the following way:
    \scm{ch3/3.03.scm}
\end{exe}

\begin{exe}[3.4]
    The procedure can be rewritten as:
    \scm{ch3/3.04.scm}
\end{exe}

\subsection{The Benefits of Introducing Assignment}

\begin{exe}[3.5]
    Using Gambit Scheme’s \vscm{random-real} procedure, that generates a random 
    real number between 0 and 1, \vscm{random-in-range} and the other procedures 
    can be written:
    \scm{ch3/3.05.scm}
\end{exe}

\begin{exe}[3.6]
    The \vscm{rand} procedure can be rewritten as:
    \scm{ch3/3.06.scm}
\end{exe}

\subsection{The Costs of Introducing Assignment}

\begin{exe}[3.7]
    I simply added a \vscm{join} action to the account returned by 
    \vscm{make-account} that creates an access with another password. I also 
    make \vscm{incorrect-password} throw an error instead of simply returning 
    a string, otherwise a call such as
    \vscm{(define new-acc (make-join account curr-pass new-pass))} with an 
    incorrect current password will affect a string value to \vscm{new-acc} 
    without reporting an error, and subsequent uses of the account will throw 
    errors because \vscm{"Incorrect password"} is not a procedure.
    \scm{ch3/3.07.scm}
\end{exe}

\begin{exe}[3.8]
    The procedure \vscm{f} returns:
    \begin{itemize}
        \item 0 if it is the first time it is called;
        \item the previous argument it was called with otherwise.
    \end{itemize}
    Thus, if we evaluate \vscm{(f 0)}, then \vscm{(f 1)}, we get 0 both times, 
    but if we evaluate \vscm{(f 1)}, then \vscm{(f 0)}, we get 0 the first 
    time and 1 the second.
    \scm{ch3/3.08.scm}
\end{exe}

\section{The Environment Model of Evaluation}

\subsection{The Rules for Evaluation}

This subsection contains no exercises.

\subsection{Applying Simple Procedures}

% Tikz styles for the environments of section 3.2.
\tikzset{env/.style={
rectangle,
rounded corners=2pt,
% border
very thick,
draw=teal!80!black,
% filling
fill=teal!10,
inner sep = 2mm,
font=\ttfamily\small,
align=left,
},
global env/.style={
env,
align=left,
inner xsep=1ex,
text width=13cm-2*\pgfkeysvalueof{/pgf/inner xsep},
minimum width=13cm,
minimum height=1.5cm
},
code/.style={
align=left,
font=\ttfamily\small,
}
}

\var{\nametoenv}{4mm}
\var{\envtonext}{3mm}
\begin{exe}[3.9]
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \node[text width=1cm, align=right] (ge) {global\\ env};
            \node[global env, right=\nametoenv of ge] (g) {factorial};
            \node[text width=1cm, align=right, below=of ge] (e1) {E1};
            \node[env, right=\nametoenv of e1] (n1) {n:\,6};
            \node[right=\envtonext of n1] (e2) {E2};
            \node[env, right=\nametoenv of e2] (n2) {n:\,5};
            \node[right=\envtonext of n2] (e3) {E3};
            \node[env, right=\nametoenv of e3] (n3) {n:\,4};
            \node[right=\envtonext of n3] (e4) {E4};
            \node[env, right=\nametoenv of e4] (n4) {n:\,3};
            \node[right=\envtonext of n4] (e5) {E5};
            \node[env, right=\nametoenv of e5] (n5) {n:\,2};
            \node[right=\envtonext of n5] (e6) {E6};
            \node[env, right=\nametoenv of e6] (n6) {n:\,1};

            \draw[->] (ge) -- (ge.west -| g.west);
            \foreach \i in {1, ..., 6} {
                \draw[->] (e\i) -- (n\i);
                \draw[->] (n\i.north) -- (n\i.north|-g.south);
                \node[code,below=2mm of n\i] { \vscm{(if ...)} };
            }
        \end{tikzpicture}
        \caption{Environments created by evaluating \vscm{(factorial 6)} with 
        the recursive procedure. In all the environments created, the code to 
        evaluate corresponds to the body of the \vscm{factorial} procedure.}
        \label{fact_rec}
    \end{figure}

    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \node[text width=1cm, align=right] (ge) {global\\ env};
            \node[global env, right=\nametoenv of ge] (g)
            {factorial\\ fact-iter};
            \node[text width=1cm, align=right, below=of ge] (e1) {E1};
            \node[env, right=\nametoenv of e1] (n1) {n:\,6};
            \node[right=\envtonext of n1] (e2) {E2};
            \node[env, right=\nametoenv of e2] (n2) {p:\,1\\ c:\,1\\ m:\,6};
            \node[right=\envtonext of n2] (e3) {E3};
            \node[env, right=\nametoenv of e3] (n3) {p:\,2\\ c:\,2\\ m:\,6};
            \node[right=(\envtonext+.6cm) of n3] (e4) {E4};
            \node[env, right=\nametoenv of e4] (n4) {p:\,6\\ c:\,3\\ m:\,6};
            \node[right=(\envtonext+.3cm) of n4] (e5) {E5};
            \node[env, right=\nametoenv of e5] (n5) {p:\,24\\ c:\,4\\ m:\,6};
            \node[below=1.9cm of n3] (e6) {E6};
            \node[env, right=\nametoenv of e6] (n6) {p:\,24\\ c:\,5\\ m:\,6};
            \node[right=\envtonext of n6] (e7) {E7};
            \node[env, right=\nametoenv of e7] (n7) {p:\,120\\ c:\,6\\ m:\,6};
            \node[right=\envtonext of n7] (e8) {E8};
            \node[env, right=\nametoenv of e8] (n8) {p:\,720\\ c:\,7\\ m:\,6};

            \draw[->] (ge) -- (ge.west -| g.west);
            \foreach \i in {1, ..., 8} {
                \draw[->] (e\i) -- (n\i);
                \draw[->] (n\i.north) -- (n\i.north|-g.south);
            }

            \node[code, below = 2mm of n1] { \vscm{(fact-iter 1 1 n)} };
            \foreach \i in {2, ..., 8} {
                \node[code, below = 2mm of n\i] { \vscm{(if ...)} };
            }
        \end{tikzpicture}
        \caption{Environments created by evaluating \vscm{(factorial 6)} with 
        the iterative procedure. In environments E2 to E8, the code to evaluate 
        corresponds to the body of the \vscm{fact-iter} procedure.}
        \label{fact_iter}
    \end{figure}

    The environment structure created by evaluating \vscm{(factorial 6)} with 
    both versions of the procedure are shown in figures \ref{fact_rec} and 
    \ref{fact_iter}.
\end{exe}

\subsection{Frames as the Repository of Local State}

\var{\circleradius}{3mm}
\var{\smallcircleradius}{.8mm}
\newcommand\pointer[1]{
\draw (#1) circle (\circleradius);
\filldraw (#1) circle (\smallcircleradius);
}
\newcommand\procedure[3]{
\coordinate[left=\circleradius of #1]  (#2);
\coordinate[right=\circleradius of #1]  (#3);
\pointer{#2}
\pointer{#3}
}

\begin{exe}[3.10]
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \matrix[matrix anchor=north west, column sep=2\nametoenv, column 
            2/.style={anchor=base west}] at (0,0) {
            \node[text width=1cm, align=right] (ge) {global\\ env}; &
            \node[code] (mkw) {make-withdraw: ...}; \\[-8pt]
            & \node[code] (w1) {W1: }; \\
            };
            \begin{scope}[on background layer]
                \coordinate (w1b) at ($ (w1.south) - (0, 10pt) $);
                \node[global env, fit=(mkw) (w1b), right=\nametoenv of ge] (g) 
                {};
            \end{scope}
            \node[text width=1cm, align=right, below=of g] (e1) {E1};
            \node[env, right=\nametoenv of e1] (n1) {initial-amount:\,100};
            \node[env, below=of n1] (n2) {balance:\,100};
            \node[left=\nametoenv of n2] (e2) {E2};
            \node[env, below=of n2] (n3) {amount:\,50};

            \coordinate[left=3cm of e1] (p1);
            \procedure{p1}{c1}{c2}
            \node[code, below=of p1] (code) {
            parameters: amount\\
            body: (if ...)
            };
            \node[code, below=1ex of n3] { (if ...) };

            \draw[->] (c1) -- (c1 |- code.north);
            \draw[->] (c2) -- ++(0, -8mm) -| ($ (n2.north) - (.5cm, 0) $);

            \draw[->] (ge) -- (ge.west -| g.west);
            \foreach \i in {1, 2}
                \draw[->] (e\i) -- (n\i);
            \draw[->] (n1.north) -- (n1.north |- g.south);
            \draw[->] (n2) -- (n1);
            \draw[->] (n3) -- (n2);
            \draw[->] (w1) -| ($ (p1) + (0, \circleradius) $);
        \end{tikzpicture}
        \caption{Environments created when executing
        \vscm{(W1 50)} after executing
        \vscm{(define (W1 (make-withdraw 100))}. The environment E1 is created 
        by the call to \vscm{make-withdraw}, E2 is created when the lambda 
        procedure created by the \vscm{let} is executed. E2 is referenced by the 
        procedure returned by \vscm{make-withdraw}. When \vscm{(W1 50)} is 
        called, a new environment pointing to E2 is created, in which the body 
        of \vscm{W1} is evaluated.}
        \label{3.10figa}
    \end{figure}

    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \matrix[matrix anchor=north west, column sep=2\nametoenv, column 
            2/.style={anchor=base west}] at (0,0) {
            & \node[code] (mkw) {make-withdraw: ...}; \\
            \node[text width=1cm, align=right] (ge) {global\\ env};& \node[code] 
            (w1) {W1: }; \\[-8pt]
            & \node[code] (w2) {W2: }; \\
            };
            \begin{scope}[on background layer]
                \coordinate (mkwb) at ($ (mkw.north) + (0, 20pt) $);
                \node[global env, fit=(mkwb) (w1), right=\nametoenv of ge] (g) 
            {};
            \end{scope}
            \coordinate (e1pos) at ($ (g.south west)!.65!(g.south east) $);
            \node[text width=1cm, align=right, below=of e1pos] (e1) {E1};
            \node[env, right=\nametoenv of e1] (n1) {initial-amount:\,100};
            \node[env, below=of n1] (n2) {balance:\,50};
            \node[left=\nametoenv of n2] (e2) {E2};

            \coordinate[left=.8cm of e1] (p1);
            \procedure{p1}{c1}{c2}
            \node[code, below=of p1] (code) {
            parameters: amount\\
            body: (if ...)
            };

            \coordinate (e3pos) at (ge |- g.south east);
            \node[text width=1cm, align=right, below=of e3pos] (e3) {E3};
            \node[env, right=\nametoenv of e3] (n3) {initial-amount:\,100};
            \node[env, below=of n3] (n4) {balance:\,100};
            \node[left=\nametoenv of n4] (e4) {E4};

            \draw[->] (c1) -- (c1 |- code.north);
            \draw[->] (c2) -- ++(0, -8mm) -| ($ (n2.north) - (.5cm, 0) $);
            \draw[->] (w1) -| ($ (p1) + (0, \circleradius) $);

            \coordinate[left=2cm of p1] (p2);
            \procedure{p2}{c3}{c4}
            \draw[->] (c3) |- (code.west);
            \draw[->] (c4) -- ++(0, -8mm) -| ($ (n4.north) + (.5cm, 0) $);
            \draw[->] (w2) -| ($ (p2) + (0, \circleradius) $);

            \draw[->] (ge) -- (ge.west -| g.west);
            \foreach \i in {1, ..., 4}
                \draw[->] (e\i) -- (n\i);
            \draw[->] (n1.north) -- (n1.north |- g.south);
            \draw[->] (n3.north) -- (n3.north |- g.south);
            \draw[->] (n2) -- (n1);
            \draw[->] (n4) -- (n3);
        \end{tikzpicture}
        \caption{Environments created after the execution of
        \vscm{(define W1 (make-withdraw 100))}, followed by \vscm{(W1 50)}, then 
        \vscm{(define W2 (make-withdraw 100))}. The call to \vscm{W1} modified 
        the value of \vscm{balance} in E2, but \vscm{W2} uses the \vscm{balance} 
        variable of environment E4.}
        \label{3.10figb}
    \end{figure}

    The environments created after the execution of the three commands are shown 
    in figures \ref{3.10figa} and \ref{3.10figb}, see the captions for some 
    details. As with the first version of \vscm{make-version}, each object 
    created with a call to \vscm{make-version} uses a \vscm{balance} binding 
    situated in an environment specific to the object.

    In the second version, two environments are created instead of one, and the 
    value of \vscm{initial-value} is unchanged.
\end{exe}

\subsection{Internal Definitions}

\begin{exe}[3.11]
    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \matrix[matrix anchor=base west, column sep=2\nametoenv, column 
            2/.style={anchor=base west}] at (0,0) {
            \node[text width=1cm, align=right] (ge) {global\\ env};
            & \node[code] (mkw) {make-account: ...}; \\[-8pt]
            & \node[code] (acc) {acc: }; \\
            };
            \coordinate (e1pos) at ($ (g.south west)!.15!(g.south east) $);
            \matrix[matrix anchor=north west, column sep=2\nametoenv,
            below=1mm of e1pos, column 2/.style={anchor=base west}] {
            \node[text width=1cm, align=right] (e1) {E1};
            & \node[code] (balance) { balance: 50}; \\[-11pt]
            & \node[code] { withdraw: ... }; \\
            & \node[code] { deposit: ... }; \\
            & \node[code] (dispatch) { dispatch: }; \\
            };
            \begin{scope}[on background layer]
                \coordinate (accb) at ($ (acc.south) - (0, 20pt) $);
                \node[global env, fit=(mkw) (accb), right=\nametoenv of ge] (g) 
                    {};
                \node[env, minimum width=4cm, fit=(balance) (dispatch), 
                right=\nametoenv of e1, yshift=-3mm] (n1) {};
            \end{scope}

            \coordinate (xp1) at ($ (n1.south)!.50!(n1.south east) $);
            \coordinate[below=of xp1] (p1);
            \procedure{p1}{c1}{c2}
            \node[code, below=of p1] (code) {
            parameters: m\\
            body: (cond ...)
            };

            \draw[->] (c1) -- (c1 |- code.north);
            \draw[->] (c2) -| ($ (n1.south east) - (3mm, 0) $);

            \draw[->] (ge) -- (ge.west -| g.west);
            \draw[->] (e1) -- (e1.east -| n1.west);
            \draw[->] (n1.north) -- (n1.north |- g.south);
            \draw[->] (dispatch) -| ($ (p1) + (0, \circleradius) $);

            \draw[->] (acc) -- ($ (acc) + (1cm, 0) $)
                |- ($ (p1) + (-2\circleradius, 0) $);

            % Evaluation of ((acc 'deposit) 40)
            \coordinate[right=2cm of n1.east] (middle);
            \node[env, above=1em of middle] (m)
            {m: 'deposit};
            \node[env, below=1em of middle] (amount) {amount: 40};
            \node[right=of m] (e2) {E2};
            \node[right=of amount] (e3) {E3};
            \draw[->] (e2) -- (m);
            \draw[->] (e3) -- (amount);
            \draw[->] (m) -- (m -| n1.east);
            \draw[->] (amount) -- (amount -| n1.east);
        \end{tikzpicture}

        \caption{Environments when evaluating \vscm{((acc 'deposit) 40)}
        after evaluating \vscm{(define acc (make-account 50))}. E1 is created 
        when defining \vscm{acc}, then the evaluation of \vscm{(acc 'deposit)}
        causes the creation of an environment referencing E1, and since the 
        result of the evaluation is the procedure \vscm{deposit}, \vscm{(deposit 
        40)} is then evaluated in a new environment.}
        \label{3.11figa}
    \end{figure}

    \begin{figure}
        \begin{tikzpicture}[>=Stealth, thick]
            \matrix[matrix anchor=base west, column sep=2\nametoenv, column 
            2/.style={anchor=base west}] at (0,0) {
            \node[text width=1cm, align=right] (ge) {global\\ env};
            & \node[code] (mkw) {make-account: ...}; \\[-8pt]
            & \node[code] (acc) {acc: }; \\
            };
            \coordinate (e1pos) at ($ (g.south west)!.15!(g.south east) $);
            \matrix[matrix anchor=north west, column sep=2\nametoenv,
            below=1cm of e1pos, column 2/.style={anchor=base west}] {
            \node[text width=1cm, align=right] (e1) {E1};
            & \node[code] (balance) { balance: 90}; \\[-11pt]
            & \node[code] { withdraw: ... }; \\
            & \node[code] { deposit: ... }; \\
            & \node[code] (dispatch) { dispatch: }; \\
            };
            \begin{scope}[on background layer]
                \coordinate (accb) at ($ (acc.south) - (0, 20pt) $);
                \node[global env, fit=(mkw) (accb), right=\nametoenv of ge] (g) 
                    {};
                \node[env, minimum width=4cm, fit=(balance) (dispatch), 
                right=\nametoenv of e1, yshift=-3mm] (n1) {};
            \end{scope}

            \coordinate (xp1) at ($ (n1.south)!.50!(n1.south east) $);
            \coordinate[below=of xp1] (p1);
            \procedure{p1}{c1}{c2}
            \node[code, below=of p1] (code) {
            parameters: m\\
            body: (cond ...)
            };

            \draw[->] (c1) -- (c1 |- code.north);
            \draw[->] (c2) -| ($ (n1.south east) - (3mm, 0) $);

            \draw[->] (ge) -- (ge.west -| g.west);
            \draw[->] (e1) -- (e1.east -| n1.west);
            \draw[->] (n1.north) -- (n1.north |- g.south);
            \draw[->] (dispatch) -| ($ (p1) + (0, \circleradius) $);

            \draw[->] (acc) -- ($ (acc) + (1cm, 0) $)
                |- ($ (p1) + (-2\circleradius, 0) $);

            % Evaluation of ((acc 'withdraw) 60)
            \coordinate[right=2cm of n1.east] (middle);
            \node[env, above=1em of middle] (m)
            {m: 'withdraw};
            \node[env, below=1em of middle] (amount) {amount: 60};
            \node[right=of m] (e4) {E4};
            \node[right=of amount] (e5) {E5};
            \draw[->] (e4) -- (m);
            \draw[->] (e5) -- (amount);
            \draw[->] (m) -- (m -| n1.east);
            \draw[->] (amount) -- (amount -| n1.east);
        \end{tikzpicture}

        \caption{Environments during the evaluation of
        \vscm{((acc 'withdraw) 60)}.}
        \label{3.11figb}
    \end{figure}

    The environments generated by the evaluation of
    \vscm{(define acc (make-account 50))},\\
    \vscm{((acc 'deposit) 40)} and \vscm{((acc 'withdraw) 60)} are shown in 
    figures \ref{3.11figa} and \ref{3.11figb}. The local state for \vscm{acc} is 
    kept in the local environment referenced by the procedure object referenced 
    by \vscm{acc}.

    If a second environment is created, its local state is kept in a new 
    environment created when evaluating the \vscm{make-account} procedure, so it 
    does not interfere with \vscm{acc}’s local environment.

    The environment structures of \vscm{acc} and \vscm{acc2} share the global 
    environment.
\end{exe}
