\chapter{Modularity, Objects, and State}

\section{Assignment and Local State}

\subsection{Local State Variables}

\begin{exe}[3.1]
    The procedure \vscm{make-accumulator} can be written:
    \scm{ch3/3.01.scm}
\end{exe}

\begin{exe}[3.2]
    The \vscm{make-monitored} procedure can be written:
    \scm{ch3/3.02.scm}
\end{exe}

\begin{exe}[3.3]
    The \vscm{make-account} procedure can be modified in the following way:
    \scm{ch3/3.03.scm}
\end{exe}

\begin{exe}[3.4]
    The procedure can be rewritten as:
    \scm{ch3/3.04.scm}
\end{exe}

\subsection{The Benefits of Introducing Assignment}

\begin{exe}[3.5]
    Using Gambit Schemeâ€™s \vscm{random-real} procedure, that generates a random 
    real number between 0 and 1, \vscm{random-in-range} and the other procedures 
    can be written:
    \scm{ch3/3.05.scm}
\end{exe}

\begin{exe}[3.6]
    The \vscm{rand} procedure can be rewritten as:
    \scm{ch3/3.06.scm}
\end{exe}

\subsection{The Costs of Introducing Assignment}

\begin{exe}[3.7]
    I simply added a \vscm{join} action to the account returned by 
    \vscm{make-account} that creates an access with another password. I also 
    make \vscm{incorrect-password} throw an error instead of simply returning 
    a string, otherwise a call such as
    \vscm{(define new-acc (make-join account curr-pass new-pass))} with an 
    incorrect current password will affect a string value to \vscm{new-acc} 
    without reporting an error, and subsequent uses of the account will throw 
    errors because \vscm{"Incorrect password"} is not a procedure.
    \scm{ch3/3.07.scm}
\end{exe}

\begin{exe}[3.8]
    The procedure \vscm{f} returns:
    \begin{itemize}
        \item 0 if it is the first time it is called;
        \item the previous argument it was called with otherwise.
    \end{itemize}
    Thus, if we evaluate \vscm{(f 0)}, then \vscm{(f 1)}, we get 0 both times, 
    but if we evaluate \vscm{(f 1)}, then \vscm{(f 0)}, we get 0 the first 
    time and 1 the second.
    \scm{ch3/3.08.scm}
\end{exe}
