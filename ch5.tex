\chapter{Computing with Register Machines}

\section{Designing Register Machines}

\begin{exe}[5.1]
    \label{5.1}
    The data-path and the controller diagrams for the iterative factorial 
    machine are shown on figure \ref{5.1fig}.

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            % Data-path diagram.
            \matrix[data matrix] (dp) {
                & \node[reg] (n) {n}; &
                \node[test] (>) {>}; \\

                & \node[const] (c1) {1}; & \\

                \node[reg] (p) {product}; &&
                \node[reg] (c) {counter}; \\

                & \node[op] (+) {+}; & \\

                & \node[op] (*) {*}; & \\
            };

            \draw[arg] (n) -- (>);
            \draw[arg] (c) -- (>);
            \draw[button=0.82] (c1) -| node[near start, above] {p<-1} (p);
            \draw[button=0.82] (c1) -| node[near start, above] {c<-1}
                ($ (c.north) + (-1em, 0) $);
            \draw[arg] (c1) -- (+);
            \draw[button=0.8] ($ (+.north) + (1em, 0) $) |-
                node[near end, above] {c++} (c);
            \draw[arg] (c) |- (+);
            \draw[arg] ($ (p.south) + (-1em, 0) $) |-
                ($ (*.south) + (0, -1.5em) $) -- (*);
            \draw[arg] (c) |- (*);
            \draw[button=0.8] (*) -| node[near end, right]{p<-*}
                ($ (p.south) + (1em, 0) $);

            % Controller diagram
            \matrix[controller matrix, right=5em of dp] {
                \node[cio] (s) {start}; \\
                \node[cbutton] (pi) {p<-1}; \\
                \node[cbutton] (ci) {c<-1}; \\
                \node[ctest] (ct) {>}; & \node[cio] (cd) {done}; \\[+1em]
                \node[cbutton] (cp) {p<-*}; \\
                \node[cbutton] (cc) {c++}; \\
            };

            \draw[flow] (s) -- (pi);
            \draw[flow] (pi) -- (ci);
            \draw[flow] (ci) -- (ct);
            \draw[flow] (ct) --node[right] {no} (cp);
            \draw[flow] (ct) --node[above] {yes} (cd);
            \draw[flow] (cp) -- (cc);
            \draw[flow] (cc) -| ($ (ct.west) - (2.5em, 0) $) -- (ct);
        \end{tikzpicture}
        \caption{The data-path and controller diagrams for the iterative 
        factorial machine.}
        \label{5.1fig}
    \end{figure}
\end{exe}

\subsection{A Language for Describing Register Machines}

\begin{exe}[5.2]
    Anticipating on the next section to use the register-machine simulator, we 
    can define the iterative factorial machine of exercise \ref{5.1} as:
    \scm{ch5/5.02.scm}
\end{exe}

\subsection{Abstraction in Machine Design}

\begin{exe}[5.3]
    Using the simulator again, the first version of the register machines can be 
    defined as:
    \scm{ch5/5.03a.scm}
    and the second version as:
    \scm{ch5/5.03b.scm}
    The data-path diagrams are shown on figures \ref{5.03afig} and 
    \ref{5.03bfig} respectively.

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix] {
                \node[const] (c1) {1};
                &[+1em] \node[reg] (g) {guess};
                & \node[test] (ge) {g-e?};
                & \node[reg] (x) {x}; \\

                && \node[op] (i) {improve}; \\
            };

            \draw[button=.5] (c1) -- (g);
            \draw[arg] (g) -- (ge);
            \draw[arg] (x) -- (ge);
            \draw[arg] ($ (g.south) + (1em, 0) $) |- (i);
            \draw[button=.7] (i.south) -- ($ (i.south) - (0, 1em) $) -|
                ($ (g.south) - (1em, 0) $);
            \draw[arg] (x) |- (i);
        \end{tikzpicture}
        \caption{The data-path diagram for the square root machine using complex 
        primitive operations.}
        \label{5.03afig}
    \end{figure}

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix, matrix of nodes, nodes in empty cells]
            (table) {%
                && \node[const] (c1) {1};
                & \node[op] (div2) {/};
                & \node[const] (c2) {2}; \\

                &&& \node[minimum height=1.5\regheight] {guess}; &&& \\

                && \node[op] (divx) {/};
                & \node[op] (*) {*};
                & \node[op] (+) {+}; \\

                & \node[reg] (x) {x};
                && \node {tmp};
                && \node[test] (<eps) {<};
                & \node[const, inner xsep = -.2em] (eps) {0.001}; \\

                && \node[op] (mx) {-};
                & \node[op] (mtmp) {-};
                & \node[test] (>0) {<};
                & \node[const] (c0) {0}; \\
            };
            \begin{scope}[on background layer]
                \node[reg, fit=(table-2-3)(table-2-5)] (guess) {};
                \node[reg, fit=(table-4-3)(table-4-5)] (tmp) {};
            \end{scope}

            \draw[button=.6] (c1) -- (guess.north -| c1);
            \draw[arg] ($ (guess.north) - (3em, 0) $) |- (div2);
            \draw[arg] (c2) -- (div2);
            \draw[button=.6] (div2) -- (guess);
            \draw[arg] (x) |- (divx);
            \draw[arg] (guess.south -| divx) -- (divx);
            \draw[button=.6] (divx) -- (tmp.north -| divx.south);
            \draw[arg] ($ (guess.south) - (1em, 0) $) --
                ($ (*.north) - (1em, 0) $);
            \draw[arg] ($ (guess.south) + (1em, 0) $) --
                ($ (*.north) + (1em, 0) $);
            \draw[button=.6] (*) -- (tmp);
            \coordinate (pc) at (guess.south -| +.north);
            \draw[arg] ($ (pc) - (1em, 0) $) -- ($ (+.north) - (1em, 0) $);
            \draw[button=.6] ($ (+.north) + (1em, 0) $) -- ($ (pc) + (1em, 0) $);
            \draw[arg] (tmp.north -| +) -- (+);
            \draw[arg] (tmp) -- (<eps);
            \draw[arg] (eps) -- (<eps);
            \draw[arg] (x) |- (mx);
            \coordinate (mc) at (tmp.south -| mx.north);
            \draw[arg] ($ (mc) - (1em, 0) $) -- ($ (mx.north) - (1em, 0) $);
            \draw[button=.6] ($ (mx.north) + (1em, 0) $) --
                ($ (mc) + (1em, 0) $);
            \draw[arg] ($ (tmp.south) - (1em, 0) $) --
                ($ (mtmp.north) - (1em, 0) $);
            \draw[button=.6] ($ (mtmp.north) + (1em, 0) $) --
                ($ (tmp.south) + (1em, 0) $);
            \draw[arg] (tmp.south -| >0) -- (>0);
            \draw[arg] (c0) -- (>0);
        \end{tikzpicture}
        \caption{The data-path diagram for the square root machine using only 
        basic primitive operations.}
        \label{5.03bfig}
    \end{figure}
\end{exe}

\subsection{Subroutines}

This subsection contains no exercises.

\subsection{Using a Stack to Implement Recursion}

\begin{exe}[5.4]
    \label{5.04}
    \ \vspace{-20pt}
    \begin{itemize}
        \item[a.] The recursive exponentiation machine can be defined as 
            follows. The corresponding data-path diagram is shown on figure 
            \ref{5.04afig}.
            \scm{ch5/5.04a.scm}
        \item[b.] The iterative exponentiation machine can be defined as 
            follows. The corresponding data-path diagram is shown on figure 
            \ref{5.04bfig}.
            \scm{ch5/5.04b.scm}
    \end{itemize}

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix] {
                \node[const] (c0) {0};
                & \node[test] (=) {=};
                & \node[reg] (n) {n};
                &[+1em] &[-4.5em] \node[reg] (stack) {stack}; \\

                \node[const] (c1) {1};
                & \node[op] (-) {-};
                &&& \node[reg] (continue) {continue};
                &[-4.5em]& \node (controller) {controller}; \\

                \node[reg] (val) {val};
                & \node[op] (*) {*};
                & \node[reg] (b) {b};
                & \node[const, inner xsep=-.2em] (ed) {e-d};
                && \node[const, inner xsep=-.2em] (ae) {a-e}; \\
            };

            \draw[arg] (c0) -- (=);
            \draw[arg] (n) -- (=);
            \draw[button=.5] ($ (n.east) + (0, .7em) $) --
                ($ (stack.west) + (0, .7em) $);
            \draw[button=.5] ($ (stack.west) - (0, .7em) $) --
                ($ (n.east) - (0, .7em) $);
            \draw[arg] (c1) -- (-);
            \draw[arg] ($ (n.south) - (.7em, 0) $) |- (-);
            \draw[button=.8] (-) -- ($ (-.south) - (0, 1em) $)
                -| ($ (n.south) + (.7em, 0) $);
            \draw[button=.5] ($ (stack.south) - (.7em, 0) $) --
                ($ (continue.north) - (.7em, 0) $);
            \draw[button=.5] ($ (continue.north) + (.7em, 0) $) --
                ($ (stack.south) + (.7em, 0) $);
            \draw[arg] (continue) -- (controller);
            \draw[arg] (c1) -- (val);
            \draw[arg] (val) -- (*);
            \draw[button=.7] (*) -- ($ (*) - (0, 3em) $) -| (val);
            \draw[arg] (b) -- (*);
            \draw[button=.5] (ed) -- (ed |- continue.south);
            \draw[button=.5] (ae) -- (ae |- continue.south);
        \end{tikzpicture}
        \caption{The data-path diagram for the recursive exponentiation 
        machine.}
        \label{5.04afig}
    \end{figure}

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix] {
                \node[reg] (b) {b};
                & \node[const] (c0) {0};
                &[+1em] \node[op] (=) {=}; \\

                \node[op] (*) {*};
                & \node[reg] (n) {n};
                & \node[reg] (c) {counter}; \\

                \node[reg] (p) {product};
                & \node[const] (c1) {1};
                & \node[op] (-) {-}; \\
            };

            \draw[arg] (c0) -- (=);
            \draw[arg] (c) -- (=);
            \draw[arg] (b) -- (*);
            \draw[arg] ($ (p.north) - (.7em, 0) $) --
                ($ (*.south) - (.7em, 0) $);
            \draw[button=.5] ($ (*.south) + (.7em, 0) $) --
                ($ (p.north) + (.7em, 0) $);
            \draw[button=.5] (n) -- (c);
            \draw[arg] (c1) -- (p);
            \draw[arg] (c1) -- (-);
            \draw[arg] ($ (c.south) - (1em, 0) $) --
                ($ (-.north) - (1em, 0) $);
            \draw[button=.5] ($ (-.north) + (1em, 0) $) --
                ($ (c.south) + (1em, 0) $);
        \end{tikzpicture}
        \caption{The data-path diagram for the iterative exponentiation 
        machine.}
        \label{5.04bfig}
    \end{figure}
\end{exe}

\begin{exe}[5.5]
    The following table lists the instructions evaluated during the simulation 
    of factorial 3, with their effect on the values of the registers \vscm{n}, 
    \vscm{val}, and \vscm{continue} and on the stack.
    \begin{longtable}{|l|c|c|c|c|}
        \hline
        \bfseries Instruction & \bfseries n & \bfseries val & \bfseries continue 
        & \bfseries stack \\\hline
        \endhead
        (assign cont (label fact-done)) & 3 & *unassigned* & fact-done & () 
        \\\hline
        (test (op =) ...) -> false &&&& \\\hline
        (branch (label base-case)) &&&& \\\hline
        (save continue) &&&& (fact-done) \\\hline
        (save n) &&&& (3 fact-done) \\\hline
        (assign n (op -) ...) & 2 &&& \\\hline
        (assign cont (label after-fact)) &&& after-fact & \\\hline
        (goto (label fact-loop)) &&&& \\\hline
        (test (op =) ...) -> false &&&& \\\hline
        (branch (label base-case)) &&&& \\\hline
        (save cont) &&&& (after-fact 3 fact-done) \\\hline
        (save n) &&&& (2 after-fact 3 fact-done) \\\hline
        (assign n (op -) ...) & 1 &&& \\\hline
        (assign cont (label after-fact)) &&& after-fact & \\\hline
        (goto (label fact-loop)) &&&& \\\hline
        (test (op =) ...) -> true &&&& \\\hline
        (branch (label base-case)) &&&& \\\hline
        (assign val (const 1)) && 1 && \\\hline
        (goto (reg cont)) -> after-fact &&&& \\\hline
        (restore n) & 2 &&& (after-fact 3 fact-done) \\\hline
        (restore cont) &&& after-fact & (3 fact-done) \\\hline
        (assign val (op *) ...) && 2 && \\\hline
        (goto (reg cont)) -> after-fact &&&& \\\hline
        (restore n) & 3 &&& (fact-done) \\\hline
        (restore cont) &&& fact-done & () \\\hline
        (assign val (op *) ...) && 6 && \\\hline
        (goto (reg cont)) -> fact-done &&&& \\\hline
    \end{longtable}

    The following table lists the instructions evaluated during the simulation 
    of fibonacci 3, with their effect on the values of the registers \vscm{n}, 
    \vscm{val}, and \vscm{continue} and on the stack.
    \begin{longtable}{|l|c|c|c|c|}
        \hline
        \bfseries Instruction & \bfseries n & \bfseries val & \bfseries continue 
        & \bfseries stack \\\hline
        \endhead
        (assign cont (label fib-done) & 3 & *unassigned* & fib-done & () 
        \\\hline
        (test (op <) ...) -> false &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (save cont) &&&& (fib-done) \\\hline
        (assign cont (label after-fib-n-1)) &&& after-fib-n-1 & \\\hline
        (save n) &&&& (3 fib-done) \\\hline
        (assign n (op -) ...1) & 2 &&& \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> false &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (save cont) &&&& (after-fib-n-1 3 fib-done) \\\hline
        (assign cont (label after-fib-n-1)) &&& after-fib-n-1 & \\\hline
        (save n) &&&& (2 after-fib-n-1 3 fib-done) \\\hline
        (assign n (op -) ...1) & 1 &&& \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> true &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (assign val (reg n)) && 1 && \\\hline
        (goto (reg cont)) -> after-fib-n-1 &&&& \\\hline
        (restore n) & 2 &&& (after-fib-n-1 3 fib-done) \\\hline
        (restore cont) &&& after-fib-n-1 & (3 fib-done) \\\hline
        (assign n (op -) ...2) & 0 &&& \\\hline
        (save cont) &&&& (after-fib-n-1 3 fib-done) \\\hline
        (assign cont (label after-fib-n-2)) &&& after-fib-n-2 & \\\hline
        (save val) &&&& (1 after-fib-n-1 3 fib-done) \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> true &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (assign val (reg n)) && 0 && \\\hline
        (goto (reg cont)) -> after-fib-n-2 &&&& \\\hline
        (assign n (reg val)) & 0 &&& \\\hline
        (restore val) && 1 && (after-fib-n-1 3 fib-done) \\\hline
        (restore cont) &&& after-fib-n-1 & (3 fib-done) \\\hline
        (assign val (op +) ...) && 1 && \\\hline
        (goto (reg cont)) -> after-fib-n-1 &&&& \\\hline
        (restore n) & 3 &&& (fib-done) \\\hline
        (restore cont) &&& fib-done & () \\\hline
        (assign n (op -) ... 2) & 1 &&& \\\hline
        (save cont) &&&& (fib-done) \\\hline
        (assign cont (label after-fib-n-2)) &&& after-fib-n-2 & \\\hline
        (save val) &&&& (1 fib-done) \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> true &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (assign val (reg n)) && 1 && \\\hline
        (goto (reg cont)) -> after-fib-n-2 &&&& \\\hline
        (assign n (reg val)) & 1 &&& \\\hline
        (restore val) && 1 && (fib-done) \\\hline
        (restore cont) &&& fib-done & () \\\hline
        (assign val (op +) ...) && 2 && \\\hline
        (goto (reg cont)) -> fib-done &&&& \\\hline
    \end{longtable}
\end{exe}

\begin{exe}[5.6]
    In \vscm{after-fib-n-1}, the instructions \vscm{(restore continue)} and 
    \vscm{(save continue)} can be removed because no change is done to the 
    \vscm{continue} register or to the stack between them.
\end{exe}

\subsection{Instruction Summary}

This subsection contains no exercises.

\section{A Register-Machine Simulator}

\begin{exe}[5.7]
    Already done while doing exercise \ref{5.04}.
\end{exe}

\subsection{The Machine Model}

This subsection contains no exercises.

\subsection{The Assembler}

\begin{exe}[5.8]
    With the simulator as written, the contents of register \vscm{a} will be 3: 
    two labels with the name \vscm{here} are present in the list of labels, but 
    the one corresponding to the first location comes first and is the one 
    returned by \vscm{lookup-label}.

    We can return an error if the same label name is used to indicate two 
    different locations by modifying \vscm{extract-labels} as follows:
    \scm{ch5/5.08.scm}
\end{exe}
