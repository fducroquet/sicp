\chapter{Computing with Register Machines}

\section{Designing Register Machines}

\begin{exe}[5.1]
    \label{5.1}
    The data-path and the controller diagrams for the iterative factorial 
    machine are shown on \autoref{5.1fig}.

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            % Data-path diagram.
            \matrix[data matrix] (dp) {
                & \node[reg] (n) {n}; &
                \node[test] (>) {>}; \\

                & \node[const] (c1) {1}; & \\

                \node[reg] (p) {product}; &&
                \node[reg] (c) {counter}; \\

                & \node[op] (+) {+}; & \\

                & \node[op] (*) {*}; & \\
            };

            \draw[arg] (n) -- (>);
            \draw[arg] (c) -- (>);
            \draw[button=0.82] (c1) -| node[near start, above] {p<-1} (p);
            \draw[button=0.82] (c1) -| node[near start, above] {c<-1}
                ($ (c.north) + (-1em, 0) $);
            \draw[arg] (c1) -- (+);
            \draw[button=0.8] ($ (+.north) + (1em, 0) $) |-
                node[near end, above] {c++} (c);
            \draw[arg] (c) |- (+);
            \draw[arg] ($ (p.south) + (-1em, 0) $) |-
                ($ (*.south) + (0, -1.5em) $) -- (*);
            \draw[arg] (c) |- (*);
            \draw[button=0.8] (*) -| node[near end, right]{p<-*}
                ($ (p.south) + (1em, 0) $);

            % Controller diagram
            \matrix[controller matrix, right=5em of dp] {
                \node[cio] (s) {start}; \\
                \node[cbutton] (pi) {p<-1}; \\
                \node[cbutton] (ci) {c<-1}; \\
                \node[ctest] (ct) {>}; & \node[cio] (cd) {done}; \\[+1em]
                \node[cbutton] (cp) {p<-*}; \\
                \node[cbutton] (cc) {c++}; \\
            };

            \draw[flow] (s) -- (pi);
            \draw[flow] (pi) -- (ci);
            \draw[flow] (ci) -- (ct);
            \draw[flow] (ct) --node[right] {no} (cp);
            \draw[flow] (ct) --node[above] {yes} (cd);
            \draw[flow] (cp) -- (cc);
            \draw[flow] (cc) -| ($ (ct.west) - (2.5em, 0) $) -- (ct);
        \end{tikzpicture}
        \caption{The data-path and controller diagrams for the iterative 
        factorial machine.}
        \label{5.1fig}
    \end{figure}
\end{exe}

\subsection{A Language for Describing Register Machines}

\begin{exe}[5.2]
    Anticipating on the next section to use the register-machine simulator, we 
    can define the iterative factorial machine of \autoref{5.1} as:
    \scm{ch5/5.02.scm}
\end{exe}

\subsection{Abstraction in Machine Design}

\begin{exe}[5.3]
    Using the simulator again, the first version of the register machines can be 
    defined as:
    \scm{ch5/5.03a.scm}
    and the second version as:
    \scm{ch5/5.03b.scm}
    The data-path diagrams are shown on figures~\ref{5.03afig} 
    and~\ref{5.03bfig} respectively.

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix] {
                \node[const] (c1) {1};
                &[+1em] \node[reg] (g) {guess};
                & \node[test] (ge) {g-e?};
                & \node[reg] (x) {x}; \\

                && \node[op] (i) {improve}; \\
            };

            \draw[button=.5] (c1) -- (g);
            \draw[arg] (g) -- (ge);
            \draw[arg] (x) -- (ge);
            \draw[arg] ($ (g.south) + (1em, 0) $) |- (i);
            \draw[button=.7] (i.south) -- ($ (i.south) - (0, 1em) $) -|
                ($ (g.south) - (1em, 0) $);
            \draw[arg] (x) |- (i);
        \end{tikzpicture}
        \caption{The data-path diagram for the square root machine using complex 
        primitive operations.}
        \label{5.03afig}
    \end{figure}

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix, matrix of nodes, nodes in empty cells]
            (table) {%
                && \node[const] (c1) {1};
                & \node[op] (div2) {/};
                & \node[const] (c2) {2}; \\

                &&& \node[minimum height=1.5\regheight] {guess}; &&& \\

                && \node[op] (divx) {/};
                & \node[op] (*) {*};
                & \node[op] (+) {+}; \\

                & \node[reg] (x) {x};
                && \node {tmp};
                && \node[test] (<eps) {<};
                & \node[const, inner xsep = -.2em] (eps) {0.001}; \\

                && \node[op] (mx) {-};
                & \node[op] (mtmp) {-};
                & \node[test] (>0) {<};
                & \node[const] (c0) {0}; \\
            };
            \begin{scope}[on background layer]
                \node[reg, fit=(table-2-3)(table-2-5)] (guess) {};
                \node[reg, fit=(table-4-3)(table-4-5)] (tmp) {};
            \end{scope}

            \draw[button=.6] (c1) -- (guess.north -| c1);
            \draw[arg] ($ (guess.north) - (3em, 0) $) |- (div2);
            \draw[arg] (c2) -- (div2);
            \draw[button=.6] (div2) -- (guess);
            \draw[arg] (x) |- (divx);
            \draw[arg] (guess.south -| divx) -- (divx);
            \draw[button=.6] (divx) -- (tmp.north -| divx.south);
            \draw[arg] ($ (guess.south) - (1em, 0) $) --
                ($ (*.north) - (1em, 0) $);
            \draw[arg] ($ (guess.south) + (1em, 0) $) --
                ($ (*.north) + (1em, 0) $);
            \draw[button=.6] (*) -- (tmp);
            \coordinate (pc) at (guess.south -| +.north);
            \draw[arg] ($ (pc) - (1em, 0) $) -- ($ (+.north) - (1em, 0) $);
            \draw[button=.6] ($ (+.north) + (1em, 0) $) -- ($ (pc) + (1em, 0) $);
            \draw[arg] (tmp.north -| +) -- (+);
            \draw[arg] (tmp) -- (<eps);
            \draw[arg] (eps) -- (<eps);
            \draw[arg] (x) |- (mx);
            \coordinate (mc) at (tmp.south -| mx.north);
            \draw[arg] ($ (mc) - (1em, 0) $) -- ($ (mx.north) - (1em, 0) $);
            \draw[button=.6] ($ (mx.north) + (1em, 0) $) --
                ($ (mc) + (1em, 0) $);
            \draw[arg] ($ (tmp.south) - (1em, 0) $) --
                ($ (mtmp.north) - (1em, 0) $);
            \draw[button=.6] ($ (mtmp.north) + (1em, 0) $) --
                ($ (tmp.south) + (1em, 0) $);
            \draw[arg] (tmp.south -| >0) -- (>0);
            \draw[arg] (c0) -- (>0);
        \end{tikzpicture}
        \caption{The data-path diagram for the square root machine using only 
        basic primitive operations.}
        \label{5.03bfig}
    \end{figure}
\end{exe}

\subsection{Subroutines}

This subsection contains no exercises.

\subsection{Using a Stack to Implement Recursion}

\begin{exe}[5.4]
    \label{5.04}
    \ \vspace{-20pt}
    \begin{enumerate}
	\item The recursive exponentiation machine can be defined as follows. 
	    The corresponding data-path diagram is shown on \autoref{5.04afig}.
            \scm{ch5/5.04a.scm}
	\item The iterative exponentiation machine can be defined as follows. 
	    The corresponding data-path diagram is shown on \autoref{5.04bfig}.
            \scm{ch5/5.04b.scm}
    \end{enumerate}

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix] {
                \node[const] (c0) {0};
                & \node[test] (=) {=};
                & \node[reg] (n) {n};
                &[+1em] &[-4.5em] \node[reg] (stack) {stack}; \\

                \node[const] (c1) {1};
                & \node[op] (-) {-};
                &&& \node[reg] (continue) {continue};
                &[-4.5em]& \node (controller) {controller}; \\

                \node[reg] (val) {val};
                & \node[op] (*) {*};
                & \node[reg] (b) {b};
                & \node[const, inner xsep=-.2em] (ed) {e-d};
                && \node[const, inner xsep=-.2em] (ae) {a-e}; \\
            };

            \draw[arg] (c0) -- (=);
            \draw[arg] (n) -- (=);
            \draw[button=.5] ($ (n.east) + (0, .7em) $) --
                ($ (stack.west) + (0, .7em) $);
            \draw[button=.5] ($ (stack.west) - (0, .7em) $) --
                ($ (n.east) - (0, .7em) $);
            \draw[arg] (c1) -- (-);
            \draw[arg] ($ (n.south) - (.7em, 0) $) |- (-);
            \draw[button=.8] (-) -- ($ (-.south) - (0, 1em) $)
                -| ($ (n.south) + (.7em, 0) $);
            \draw[button=.5] ($ (stack.south) - (.7em, 0) $) --
                ($ (continue.north) - (.7em, 0) $);
            \draw[button=.5] ($ (continue.north) + (.7em, 0) $) --
                ($ (stack.south) + (.7em, 0) $);
            \draw[arg] (continue) -- (controller);
            \draw[arg] (c1) -- (val);
            \draw[arg] (val) -- (*);
            \draw[button=.7] (*) -- ($ (*) - (0, 3em) $) -| (val);
            \draw[arg] (b) -- (*);
            \draw[button=.5] (ed) -- (ed |- continue.south);
            \draw[button=.5] (ae) -- (ae |- continue.south);
        \end{tikzpicture}
        \caption{The data-path diagram for the recursive exponentiation 
        machine.}
        \label{5.04afig}
    \end{figure}

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix] {
                \node[reg] (b) {b};
                & \node[const] (c0) {0};
                &[+1em] \node[op] (=) {=}; \\

                \node[op] (*) {*};
                & \node[reg] (n) {n};
                & \node[reg] (c) {counter}; \\

                \node[reg] (p) {product};
                & \node[const] (c1) {1};
                & \node[op] (-) {-}; \\
            };

            \draw[arg] (c0) -- (=);
            \draw[arg] (c) -- (=);
            \draw[arg] (b) -- (*);
            \draw[arg] ($ (p.north) - (.7em, 0) $) --
                ($ (*.south) - (.7em, 0) $);
            \draw[button=.5] ($ (*.south) + (.7em, 0) $) --
                ($ (p.north) + (.7em, 0) $);
            \draw[button=.5] (n) -- (c);
            \draw[arg] (c1) -- (p);
            \draw[arg] (c1) -- (-);
            \draw[arg] ($ (c.south) - (1em, 0) $) --
                ($ (-.north) - (1em, 0) $);
            \draw[button=.5] ($ (-.north) + (1em, 0) $) --
                ($ (c.south) + (1em, 0) $);
        \end{tikzpicture}
        \caption{The data-path diagram for the iterative exponentiation 
        machine.}
        \label{5.04bfig}
    \end{figure}
\end{exe}

\begin{exe}[5.5]
    The following table lists the instructions evaluated during the simulation 
    of factorial 3, with their effect on the values of the registers \vscm{n}, 
    \vscm{val}, and \vscm{continue} and on the stack.
    \begin{longtable}{|l|c|c|c|c|}
        \hline
        \bfseries Instruction & \bfseries n & \bfseries val & \bfseries continue 
        & \bfseries stack \\\hline
        \endhead
        (assign cont (label fact-done)) & 3 & *unassigned* & fact-done & () 
        \\\hline
        (test (op =) ...) -> false &&&& \\\hline
        (branch (label base-case)) &&&& \\\hline
        (save continue) &&&& (fact-done) \\\hline
        (save n) &&&& (3 fact-done) \\\hline
        (assign n (op -) ...) & 2 &&& \\\hline
        (assign cont (label after-fact)) &&& after-fact & \\\hline
        (goto (label fact-loop)) &&&& \\\hline
        (test (op =) ...) -> false &&&& \\\hline
        (branch (label base-case)) &&&& \\\hline
        (save cont) &&&& (after-fact 3 fact-done) \\\hline
        (save n) &&&& (2 after-fact 3 fact-done) \\\hline
        (assign n (op -) ...) & 1 &&& \\\hline
        (assign cont (label after-fact)) &&& after-fact & \\\hline
        (goto (label fact-loop)) &&&& \\\hline
        (test (op =) ...) -> true &&&& \\\hline
        (branch (label base-case)) &&&& \\\hline
        (assign val (const 1)) && 1 && \\\hline
        (goto (reg cont)) -> after-fact &&&& \\\hline
        (restore n) & 2 &&& (after-fact 3 fact-done) \\\hline
        (restore cont) &&& after-fact & (3 fact-done) \\\hline
        (assign val (op *) ...) && 2 && \\\hline
        (goto (reg cont)) -> after-fact &&&& \\\hline
        (restore n) & 3 &&& (fact-done) \\\hline
        (restore cont) &&& fact-done & () \\\hline
        (assign val (op *) ...) && 6 && \\\hline
        (goto (reg cont)) -> fact-done &&&& \\\hline
    \end{longtable}

    The following table lists the instructions evaluated during the simulation 
    of fibonacci 3, with their effect on the values of the registers \vscm{n}, 
    \vscm{val}, and \vscm{continue} and on the stack.
    \begin{longtable}{|l|c|c|c|c|}
        \hline
        \bfseries Instruction & \bfseries n & \bfseries val & \bfseries continue 
        & \bfseries stack \\\hline
        \endhead
        (assign cont (label fib-done) & 3 & *unassigned* & fib-done & () 
        \\\hline
        (test (op <) ...) -> false &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (save cont) &&&& (fib-done) \\\hline
        (assign cont (label after-fib-n-1)) &&& after-fib-n-1 & \\\hline
        (save n) &&&& (3 fib-done) \\\hline
        (assign n (op -) ...1) & 2 &&& \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> false &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (save cont) &&&& (after-fib-n-1 3 fib-done) \\\hline
        (assign cont (label after-fib-n-1)) &&& after-fib-n-1 & \\\hline
        (save n) &&&& (2 after-fib-n-1 3 fib-done) \\\hline
        (assign n (op -) ...1) & 1 &&& \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> true &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (assign val (reg n)) && 1 && \\\hline
        (goto (reg cont)) -> after-fib-n-1 &&&& \\\hline
        (restore n) & 2 &&& (after-fib-n-1 3 fib-done) \\\hline
        (restore cont) &&& after-fib-n-1 & (3 fib-done) \\\hline
        (assign n (op -) ...2) & 0 &&& \\\hline
        (save cont) &&&& (after-fib-n-1 3 fib-done) \\\hline
        (assign cont (label after-fib-n-2)) &&& after-fib-n-2 & \\\hline
        (save val) &&&& (1 after-fib-n-1 3 fib-done) \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> true &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (assign val (reg n)) && 0 && \\\hline
        (goto (reg cont)) -> after-fib-n-2 &&&& \\\hline
        (assign n (reg val)) & 0 &&& \\\hline
        (restore val) && 1 && (after-fib-n-1 3 fib-done) \\\hline
        (restore cont) &&& after-fib-n-1 & (3 fib-done) \\\hline
        (assign val (op +) ...) && 1 && \\\hline
        (goto (reg cont)) -> after-fib-n-1 &&&& \\\hline
        (restore n) & 3 &&& (fib-done) \\\hline
        (restore cont) &&& fib-done & () \\\hline
        (assign n (op -) ... 2) & 1 &&& \\\hline
        (save cont) &&&& (fib-done) \\\hline
        (assign cont (label after-fib-n-2)) &&& after-fib-n-2 & \\\hline
        (save val) &&&& (1 fib-done) \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> true &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (assign val (reg n)) && 1 && \\\hline
        (goto (reg cont)) -> after-fib-n-2 &&&& \\\hline
        (assign n (reg val)) & 1 &&& \\\hline
        (restore val) && 1 && (fib-done) \\\hline
        (restore cont) &&& fib-done & () \\\hline
        (assign val (op +) ...) && 2 && \\\hline
        (goto (reg cont)) -> fib-done &&&& \\\hline
    \end{longtable}
\end{exe}

\begin{exe}[5.6]
    \label{5.6}
    In \vscm{after-fib-n-1}, the instructions \vscm{(restore continue)} and 
    \vscm{(save continue)} can be removed because no change is done to the 
    \vscm{continue} register or to the stack between them.
\end{exe}

\subsection{Instruction Summary}

This subsection contains no exercises.

\section{A Register-Machine Simulator}

\begin{exe}[5.7]
    Already done while doing \autoref{5.04}.
\end{exe}

\subsection{The Machine Model}

This subsection contains no exercises.

\subsection{The Assembler}

\begin{exe}[5.8]
    With the simulator as written, the contents of register \vscm{a} will be 3: 
    two labels with the name \vscm{here} are present in the list of labels, but 
    the one corresponding to the first location comes first and is the one 
    returned by \vscm{lookup-label}.

    We can return an error if the same label name is used to indicate two 
    different locations by modifying \vscm{extract-labels} as follows:
    \scm{ch5/5.08.scm}
\end{exe}

\subsection{Generating Execution Procedures for Instructions}

\begin{exe}[5.9]
    We can forbid labels as arguments to operations by adding a test to the 
    \vscm{make-operation-exp} procedure:
    \scm{ch5/5.09.scm}
\end{exe}

\begin{exe}[5.10]
    I only modified the syntax of \vscm{op}, for instance
    \vscm{(assign <reg-name> (op <op-name>) <args>)} becomes
    \vscm{(assign <reg-name> op <op-name> <args>)}:
    \scm{ch5/5.10.scm}
\end{exe}

\begin{exe}[5.11]
    \ \vspace{-20pt}
    \begin{enumerate}
	\item After the label \vscm{after-fib-n-2}, the last value placed on the 
	    stack is $\Fib(n - 1)$, and the \vscm{val} register contains $\Fib(n 
	    - 2)$. The Fibonacci machine places $\Fib(n - 2)$ in the \vscm{n} 
	    register before restoring the last saved value in the \vscm{val} 
	    register. We can instead restore the last saved value in the 
	    \vscm{n} register and remove an assignment operation. So the lines:
            \begin{cscm}
                (assign n (reg val))
                (restore val)
            \end{cscm}
            become:
            \begin{cscm}
                (restore n)
            \end{cscm}
	\item We need to change \vscm{make-save} to put the register name on the 
	    stack, and \vscm{make-restore} to check that the original register 
	    corresponds to the target register:
	    \scm{ch5/5.11b.scm}
	\item I chose to modify \vscm{make-register} to directly add a stack to 
	    each register:
	    \scm{ch5/5.11c.scm}
	    Some other procedures must be modified as well: no stack is needed 
	    anymore in
	    \linebreak
	    \vscm{make-new-machine}, and the \vscm{stack} parameter can be 
	    removed from
	    \linebreak
	    \vscm{make-execution-procedure}. As indicated in the text, the 
	    \vscm{initialize-stack} operation should initialize all the register 
	    stacks, which can be done by replacing the original definition of 
	    \vscm{the-ops} in \vscm{make-new-machine} with:
	    \scm{ch5/5.11c-init.scm}
    \end{enumerate}
\end{exe}

\begin{exe}[5.12]
    \label{5.12}
    Since we need ordered sets, we first reuse a slightly modified version of 
    the representation of sets as ordered lists defined in 
    \secref[Sets-as-ordered-lists]{2.3.3}:
    \scm{ch5/5.12set.scm}
    To store the list of all instructions, we change \vscm{assemble} and 
    \vscm{extract-label} to build the list gradually as the instructions are 
    processed and then add it to the machine:
    \scm{ch5/5.12a1.scm}
    We also modify \vscm{make-new-machine} to define \vscm{instructions-list} as 
    the empty list at first and add new cases to the \vscm{dispatch} procedure:
    \scm{ch5/5.12a2.scm}
    To store the lists of the registers used to hold entry points and of the 
    registers that are \vscm{saved} or \vscm{restored}, we change 
    \vscm{make-new-machine} to define those lists, as well as procedures to add 
    an element to them and new messages to access them:
    \scm{ch5/5.12b2.scm}
    We then modify \vscm{make-goto}, \vscm{make-save} and \vscm{make-restore} to 
    add elements to the lists:
    \scm{ch5/5.12b1.scm}
    To store the sources from which each register is assigned, we change 
    \vscm{make-register} to store this information in each register, and 
    \vscm{make-assign} to add the sources to the target register. We also define 
    a \vscm{get-sources} procedure to access this information more easily:
    \scm{ch5/5.12c.scm}
\end{exe}

\begin{exe}[5.13]
    We change \vscm{make-machine} so it does not take a list of registers as an 
    argument:
    \scm{ch5/5.13a.scm}
    Then, we change the \vscm{lookup-register} procedure in 
    \vscm{make-new-machine} so that it allocates a new register if no register 
    with the given name exists. I also modified \vscm{allocate-register} to 
    return the newly allocated register to simplify the procedures. The dispatch 
    clause for \vscm{allocate-register} can be removed.
    \scm{ch5/5.13b.scm}
\end{exe}

\subsection{Monitoring Machine Performance}

\begin{exe}[5.14]
    The recursive factorial machine can be modified as shown below to initialize 
    the stack and print the statistics.
    \scm{ch5/5.14.scm}
    The total number of push operations and the maximum stack depth used in 
    computing $n!$ are both equal to $2 (n - 1)$: the \vscm{n} and 
    \vscm{continue} registers are each saved $n - 1$ times, then all the 
    elements of the stack are popped.
\end{exe}

\begin{exe}[5.15]
    We need to change \vscm{make-new-machine} at three places:
    \begin{enumerate}[label=\arabic*.]
	\item Add an \vscm{instruction-count} in the variables defined by the 
	    \vscm{let} at the beginning:
	    \begin{cscm}
		(instruction-count 0)
	    \end{cscm}

	\item Modify \vscm{execute} to increase the count before executing the 
	    procedure:
	    \scm{ch5/5.15a.scm}

	\item Add a message to the \vscm{dispatch} procedure to print and reset 
	    the count:
	    \scm{ch5/5.15b.scm}
    \end{enumerate}
\end{exe}

\begin{exe}[5.16]
    As in the previous exercise, the \vscm{make-new-machine} procedure must be 
    modified in three places:
    \begin{enumerate}[label=\arabic*.]
	\item Add a \vscm{trace} variable (initialized to \vscm{false}).
	\item Modify \vscm{execute} to display the instruction:
	    \scm{ch5/5.16a.scm}
	\item Add the messages \vscm{trace-on} and \vscm{trace-off} to the 
	    \vscm{dispatch} procedure:
	    \scm{ch5/5.16b.scm}
    \end{enumerate}
\end{exe}

\begin{exe}[5.17]
    \label{5.17}
    First, we change the representation of instructions from a pair to a list of 
    three elements: the instruction text, the label immediately preceding the 
    instruction, and the execution procedure.
    \scm{ch5/5.17a.scm}
    Then, we change \vscm{make-label-entry} so that it sets the label name of 
    the instruction following the label, if any:
    \scm{ch5/5.17b.scm}
    Lastly, we define a procedure to print an instruction and call it in 
    \vscm{execute}:
    \scm{ch5/5.17c.scm}
\end{exe}

\begin{exe}[5.18]
    We can modify the \vscm{make-register} procedure and define procedures to 
    turn tracing on and off for a given register as shown below. This extends 
    the definition of \vscm{make-register} from \autoref{5.12}.
    \scm{ch5/5.18.scm}
\end{exe}

\begin{exe}[5.19]
    The procedures described in the text are just syntactic sugar:
    \scm{ch5/5.19a.scm}
    We will need the labels in order to find the instruction where to put the 
    breakpoint, so we add a message to set them to the machine and set them in 
    \vscm{assemble}:
    \scm{ch5/5.19b.scm}
    We add the appropriate messages to the \vscm{dispatch} procedure in 
    \vscm{make-new-machine}:
    \scm{ch5/5.19c.scm}
    A breakpoint is defined as a pair containing the label and offset, and the 
    representation of instructions from \autoref{5.17} is extended to include 
    the breakpoint. We define procedures to check if an instruction has 
    a breakpoint and to remove the breakpoint from an instruction as well.
    \scm{ch5/5.19d.scm}
    The only missing part is the code actually handling the messages:
    \begin{itemize}
	\item To set or cancel a breakpoint, we look up the instruction 
	    corresponding to the given label and offset and add or remove the 
	    breakpoint to the instruction.
	\item To cancel all breakpoints, we remove any breakpoint from each 
	    instruction in the instruction sequence.
	\item The \vscm{execute} procedure is modified to check if the next 
	    instruction has a breakpoint. If so, it prints the information 
	    regarding the breakpoint and stops executing instructions.
	\item To continue execution, we just call \vscm{execute}, but we need to 
	    tell this procedure that it should not check again whether the next 
	    instruction is a breakpoint (we know it is and we already stopped), 
	    which we do with an additional parameter to \vscm{execute}, which is 
	    \vscm{false} only when proceeding from a breakpoint.
    \end{itemize}
    \scm{ch5/5.19e.scm}
\end{exe}

\section{Storage Allocation and Garbage Collection}

\subsection{Memory as Vectors}

\begin{exe}[5.20]
    The box-and-pointer representation and the memory-vector representation of 
    the given list structure are shown in \autoref{5.20y}. The final value of 
    \vscm{free} is \vscm{p4}. The values of \vscm{x} and \vscm{y} are 
    represented by the pointers \vscm{p1} and \vscm{p3} respectively.
    \begin{figure}
        \centering
	\begin{tikzpicture}[box and pointer]
	    % Box-and-pointer representation.
	    \matrix[cell matrix] (box-pointer) {
		\node[struct name] (y) {y}; &[+2\boxsize]
		\node[car, label=225:{3}] (c11) {}; & \node[cdr] (c12) {}; 
		&[+\boxsize]
		\node[car, label=225:{2}] (c13) {}; & \node[cdr] (c14) {}; \\

		\node[struct name] (x) {x}; &[+2\boxsize]
		\node[car, label=225:{1}] (c21) {}; & \node[cdr] (c22) {}; &
		\node[box] (n2) {2}; \\

		&
		\node[box] (n1) {1}; \\
	    };

	    \draw[pointer] (y) -- (c11);
	    \draw[pointer] (x) -- (c21);
            \link{c11}{c21}
            \link{c12}{c13}
	    \draw[box pointer] (c13.base) -- ++(0, -1cm) -| (c22);
	    \nil{c14}
	    \link{c21}{n1}
	    \link{c22}{n2}

	    % Memory-vector representation.
	    \node[right=of box-pointer] {
	    \renewcommand*\arraystretch{1.5}
	    \newcommand*\mc[1]{\multicolumn{1}{|c}{#1}}
	    \newcommand*\emc{\mc{\hphantom{n1}}}
	    \setlength{\arrayrulewidth}{1pt}
	    \begin{tabular}{rcccccc}
		Index & 0 & 1 & 2 & 3 & 4 & ... \\\cline{2-7}
		the-cars & \emc & \mc{n1} & \mc{p1} & \mc{p1} & \emc & \mc{...} 
		\\\cline{2-7}
		the-cdrs & \emc & \mc{n2} & \mc{e0} & \mc{p2} & \emc & \mc{...} 
		\\\cline{2-7}
	    \end{tabular}
	    };
	\end{tikzpicture}
	\caption{The list structure produced by \vscm{(define x (cons 1 2))} 
	followed by \vscm{(define y (list x x))}.}
	\label{5.20y}
    \end{figure}
\end{exe}

\begin{exe}[5.21]
    \ \vspace{-20pt}
    \begin{enumerate}
	\item We can define a register machine to count the leaves of a tree as 
	    follows:
	    \scm{ch5/5.21a.scm}
	\item The register machine with an explicit counter can be defined as 
	    follows. This version is simpler because the second recursion can be 
	    transformed into a loop.
	    \scm{ch5/5.21b.scm}
    \end{enumerate}
\end{exe}

\begin{exe}[5.22]
    We can define the \vscm{append-machine} and \vscm{append!-machine} as 
    follows. The second version is simpler because there is a simple loop while 
    the first version uses recursion.
    \scm{ch5/5.22a.scm}
    \scm{ch5/5.22b.scm}
\end{exe}

\subsection{Maintaining the Illusion of Infinite Memory}

This subsection contains no exercises.

\section{The Explicit-Control Evaluator}

\subsection{The Core of the Explicit-Control Evaluator}

This subsection contains no exercises.

\subsection{Sequence Evaluation and Tail Recursion}

This subsection contains no exercises.

\subsection{Conditionals, Assignments, and Definitions}

\begin{exe}[5.23]
    I added the expressions \vscm{cond} (including the alternative syntax from 
    \autoref{4.5}), \vscm{and} and \vscm{or} from \autoref{4.4}, \vscm{let} 
    (\ref{4.6} and~\ref{4.8}), \vscm{let*} (\ref{4.7}), \vscm{letrec} 
    (\ref{4.20}), and \vscm{while}, \vscm{until} and \vscm{for} from 
    \autoref{4.9}.

    The changes are similar for each expression type, so I am including them 
    here only for \vscm{cond} expressions. Besides loading the necessary syntax 
    predicates, selectors and transformers, we add a new test to the 
    \vscm{eval-dispatch} loop:
    \begin{cscm}
	(test (op cond?) (reg exp))
	(branch (label ev-cond))
    \end{cscm}
    At the given label, we transform the expression to evaluate before going 
    back to \vscm{eval-dispatch}:
    \begin{cscm}
    ev-cond
        (assign exp (op cond->if) (reg exp))
        (goto (label eval-dispatch))
    \end{cscm}
    It is tempting to go to \vscm{ev-if} instead, but if the \vscm{cond} 
    expression has no clauses, \vscm{cond->if} simply returns \vscm{false}, 
    which is not an \vscm{if} expression, so this would lead to an error. 
    Several other transformations (\vscm{and}, \vscm{or}, \vscm{let}...) also do 
    not always return an expression of the same type, so I chose to always 
    return to the \vscm{eval-dispatch} label after the transformation, even if 
    in some cases we could directly jump to the right expression type.
\end{exe}

\begin{exe}[5.24]
    We can implement \vscm{cond} as a new special form by replacing the 
    instructions handling such expressions with the instructions included below.

    The instructions are a translation of the \vscm{cond->if} procedure to 
    register-machine code.

    The loop starts at the label \vscm{ev-cond-clauses}, at which point the 
    \vscm{unev} register holds the remaining clauses. We first check if there 
    are remaining clauses. If no clauses remain, either because the \vscm{cond} 
    was empty or because no predicate was true, we return \vscm{false}. Then we 
    test whether the next clause is an \vscm{else} clause:
    \begin{itemize}
	\item If not, we evaluate the next clause’s predicate, after saving all 
	    the registers that could be needed later.
	    \begin{itemize}
		\item If the predicate is true, we evaluate the clause’s actions 
		    as a sequence. We save \vscm{continue} because it should be 
		    on the stack when reaching \vscm{ev-sequence}.
		\item If the predicate is false, we update \vscm{unev} to remove 
		    the first clause and go back to the beginning of the loop.
	    \end{itemize}
	\item If so, we check whether it is the last clause:
	    \begin{itemize}
		\item If not, we raise an error.
		\item If so, we evaluate the actions, as when a true predicate 
		    is found.
	    \end{itemize}
    \end{itemize}
    \scm{ch5/5.24b.scm}
\end{exe}

\begin{exe}[5.25]
    I used some procedures for thunk manipulation from 
    \secref[Representing-thunks]{4.2} as primitive procedures: \vscm{delay-it}, 
    \vscm{thunk?}, \vscm{thunk-exp}, \vscm{thunk-env}, \vscm{evaluated-thunk?} 
    and \vscm{thunk-value}.

    The other changes to the evaluator described in that section are implemented 
    in the explicit-control evaluator: I modified \vscm{ev-application}, 
    \vscm{apply-dispatch}, \vscm{ev-if} and the driver loop. For this, the 
    equivalent of \vscm{actual-value} in the explicit-control evaluator is 
    needed.

    The \vscm{actual-value} procedure from \secref[Modifying-the-evaluator]{4.2} 
    just calls \vscm{force-it} on the result of \vscm{eval}, so in the register 
    machine, it saves the \vscm{continue} register and goes to \vscm{force-it} 
    at the end of \vscm{eval-dispatch}. At the \vscm{force-it} label, the 
    \vscm{continue} register is restored, then the actual value of the contents 
    of the \vscm{val} register is computed, and if \vscm{val} contained a thunk 
    it is turned into an evaluated thunk.
    \begin{cscm}
    actual-value
        (save continue)
        (assign continue (label force-it))
        (goto (label eval-dispatch))
    force-it
        ;; Forces value of reg val.
        ; Saved at actual-value
        (restore continue)
        (test (op thunk?) (reg val))
        (branch (label force-thunk))
        (test (op evaluated-thunk?) (reg val))
        (branch (label force-evaluated-thunk))
        (goto (reg continue))
    force-thunk
        (assign env (op thunk-env) (reg val))
        (assign exp (op thunk-exp) (reg val))
        ; Comment out the following 3 lines to use unmemoized force-it.
        (save val) ; Save thunk to set its value later.
        (save continue)
        (assign continue (label thunk-result-forced))
        (goto (label actual-value))
    thunk-result-forced
        ; val contains the actual value.
        (assign exp (reg val))
        (restore continue)
        (restore val) ; Thunk
        (perform (op set-car!) (reg val) (const evaluated-thunk))
        (assign unev (op cdr) (reg val))
        (perform (op set-car!) (reg unev) (reg exp))
        (perform (op set-cdr!) (reg unev) (const ()))
        (assign val (reg exp))
        (goto (reg continue))
    force-evaluated-thunk
        (assign val (op thunk-value) (reg val))
        (goto (reg continue)))))
    \end{cscm}
    The above instructions implement the memoized version of \vscm{force-it}. To 
    use the non-memoized version, it is enough to comment out the lines that set 
    up the stack and the continuation so that the thunk is turned into an 
    evaluated thunk once its value has been computed: that way the 
    \vscm{thunk-result-forced} label is never reached, so no evaluated thunks 
    are created.

    With these instructions for \vscm{actual-value}, the only change needed at 
    the places where \vscm{actual-value} is used in the lazy evaluator is to 
    replace \vscm{(goto (label eval-dispatch))} with
    \vscm{(goto (label actual-value))}, which is the only change needed in 
    \vscm{read-eval-print-loop} and in \vscm{ev-if}.

    Significant changes to \vscm{ev-application} and \vscm{apply-dispatch} are 
    needed. The instructions at \vscm{ev-application} are simplified since the 
    argument accumulation is now left to \vscm{apply-dispatch}. The actual value 
    of the operator is computed and stored in \vscm{proc}, the operand 
    expressions are put in \vscm{unev}, and the rest is left to 
    \vscm{apply-dispatch}:
    \begin{cscm}
    ev-application
        (save continue)
        (save env)
        (assign unev (op operands) (reg exp))
        (save unev)
        (assign exp (op operator) (reg exp))
        (assign continue (label ev-appl-did-operator))
        (goto (label actual-value))
    ev-appl-did-operator
        (restore unev)          ; the operands
        (restore env)
        (assign proc (reg val)) ; the operator
        (goto (label apply-dispatch))
    \end{cscm}

    The beginning of \vscm{apply-dispatch} does not change much: it dispatches 
    on the procedure type. It also initializes the argument list.
    \begin{cscm}
    apply-dispatch
        ; Actual value of procedure to apply in proc, operand expressions in 
        ; unev, environment in env.
        (assign argl (op empty-arglist))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-apply))
        (test (op compound-procedure?) (reg proc))
        (branch (label compound-apply))
        (goto (label unknown-procedure-type))
    \end{cscm}

    Before applying a primitive procedure, the actual values of the arguments 
    must be computed and accumulated in \vscm{argl}, which was previously done 
    in \vscm{ev-application}. The instructions are almost the same as those used 
    in \vscm{ev-application} in the applicative-order evaluator, the main 
    difference is the use of \vscm{actual-value} rather than 
    \vscm{eval-dispatch} to compute each argument value.
    \begin{cscm}
    primitive-apply
        ; Accumulate actual values of arguments in argl.
        (save proc)
        (test (op no-operands?) (reg unev))
        (branch (label actual-primitive-apply))
    ev-appl-operand-loop
        (save argl)
        (assign exp (op first-operand) (reg unev))
        (test (op last-operand?) (reg unev))
        (branch (label ev-appl-last-arg))
        (save env)
        (save unev)
        (assign continue (label ev-appl-accumulate-arg))
        (goto (label actual-value))
    ev-appl-accumulate-arg
        (restore unev)
        (restore env)
        (restore argl)
        (assign argl (op adjoin-arg) (reg val) (reg argl))
        (assign unev (op rest-operands) (reg unev))
        (goto (label ev-appl-operand-loop))
    ev-appl-last-arg
        (assign continue (label ev-appl-accum-last-arg))
        (goto (label actual-value))
    ev-appl-accum-last-arg
        (restore argl)
        (assign argl (op adjoin-arg) (reg val) (reg argl))
    actual-primitive-apply
        (restore proc)
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (restore continue)
        (goto (reg continue))
    \end{cscm}

    Before applying a compound procedure, the delayed arguments are accumulated. 
    Though the procedures \vscm{list-of-arg-values} and 
    \vscm{list-of-delayed-args} are very similar in 
    \secref[Modifying-the-evaluator]{4.2}, their register-machine translations 
    are very different: for the latter no actual computation besides the 
    argument accumulation is done so we can use a simple loop without using the 
    stack at all, unlike the implementation of \vscm{list-of-arg-values} above.
    \begin{cscm}
    compound-apply
        ; Accumulate delayed arguments in argl.
        (test (op no-operands?) (reg unev))
        (branch (label actual-compound-apply))
        (assign exp (op first-operand) (reg unev))
        (assign exp (op delay-it) (reg exp) (reg env))
        (assign argl (op adjoin-arg) (reg exp) (reg argl))
        (assign unev (op rest-operands) (reg unev))
        (goto (label compound-apply))
    actual-compound-apply
        (assign unev (op procedure-parameters) (reg proc))
        (assign env (op procedure-environment) (reg proc))
        (assign env (op extend-environment) (reg unev) (reg argl) (reg env))
        (assign unev (op procedure-body) (reg proc))
        (goto (label ev-sequence))
    \end{cscm}
\end{exe}

\subsection{Running the Evaluator}

\begin{exe}[5.26]
    \ \vspace{-20pt}
    \begin{enumerate}
	\item The maximum depth is 10 for $n \geq 1$. For $n = 0$ the maximum 
	depth is 8.

    \item The number of pushes for any $n \geq 0$ is equal to $35n + 29$.
    \end{enumerate}
\end{exe}

\begin{exe}[5.27]
    The results found are, for any $n \geq 1$:
    \begin{center}
	\begin{tabular}{|c|c|c|}
	    \hline
	    & Maximum depth & Number of pushes \\\hline
	    Recursive factorial & $5n + 3$ & $32n - 16$ \\\hline
	    Iterative factorial & $10$ & $35n + 29$ \\\hline
	\end{tabular}
    \end{center}
\end{exe}

\begin{exe}[5.28]
    With a non tail-recursive evaluator, both procedures now require space and 
    time that grow linearly with their input. The results can be summed up in 
    the following table, for any $n \geq 1$:
    \begin{center}
	\begin{tabular}{|c|c|c|}
	    \hline
	    & Maximum depth & Number of pushes \\\hline
	    Recursive factorial & $8n + 3$ & $34n - 16$ \\\hline
	    Iterative factorial & $3n + 14$ & $37n + 33$ \\\hline
	\end{tabular}
    \end{center}
\end{exe}

\begin{exe}[5.29]
    \label{5.29}
    The figures for small values of $n$ are:
    \begin{center}
	\begin{tabular}{|c|c|c|}
	    \hline
	    \textbf{$n$} & \textbf{Maximum depth} & \textbf{Number of pushes} 
	    \\\hline
	    0 & 8 & 16 \\\hline
	    1 & 8 & 16 \\\hline
	    2 & 13 & 72 \\\hline
	    3 & 18 & 128 \\\hline
	    4 & 23 & 240 \\\hline
	    5 & 28 & 408 \\\hline
	\end{tabular}
    \end{center}
    \begin{enumerate}
	\item Since we know that the space grows linearly, we can deduce from 
	    the collected data that for $n \geq 1$, the maximum depth of the 
	    stack required is $5n + 3$.
	\item To compute $\Fib(n)$, we need to compute $\Fib(n - 1)$
	    and $\Fib(n - 2)$ and then to add the results. The operations needed 
	    to compute $\Fib(n)$ from $\Fib(n - 1)$ and $\Fib(n - 2)$ are 
	    independent of $n$, so we can expect that for any $n \geq 2$,
	    $S(n) = S(n - 1) + S(n - 2) + k$ where $k$ is independent of $n$. We 
	    can check that this is true on the collected data and find that $k 
	    = 40$.

	    By adding 40 to each side of the equation, we can rewrite it as
	    \[ S(n) + 40 = \left(S(n - 1) + 40\right)
			   + \left(S(n - 2) + 40\right) \]
	    So the sequence $S(n) + 40$ verifies the same recurrence 
	    relationship as the Fibonacci sequence, but its first values are 
	    $56, 56,…$ whereas the first values of the Fibonacci sequence are 
	    $0, 1, 1,…$. So $S(n) + 40 = 56 \Fib(n + 1)$, in other words
	    \[ S(n) = 56 \Fib(n + 1) - 40 \]
    \end{enumerate}
\end{exe}

\begin{exe}[5.30]
    \label{5.30}
    \ \vspace{-20pt}
    \begin{enumerate}
	\item For the error condition codes, I used uninterned symbols because 
	    they are guaranteed not to be equal to any symbol but themselves. 
	    I did not use a tagged list such as \vscm{(error <msg>)} because 
	    this could be the value of a user variable. Three places must be 
	    modified: \vscm{extend-environment}, \vscm{lookup-variable-value} 
	    and \vscm{set-variable-value!}. The modified version of these 
	    procedures is:
	    \scm{ch5/5.30a.scm}
	    Each of these procedures is used at one place in the evaluator, so 
	    there are three places to modify. Note that we must also use 
	    a quasiquote instead of a quote for the controller instructions so 
	    that the variables holding the error condition codes can be 
	    evaluated.
	    For \vscm{lookup-variable-value}, we modify \vscm{ev-variable}:
	    \begin{cscm}
		ev-variable
		    (assign val
			    (op lookup-variable-value)
			    (reg exp)
			    (reg env))
		    (test (op eq?) (reg val) (const ,err-unbound-var))
		    (branch (label err-lookup-unbound-var))
		    (goto (reg continue))
		err-lookup-unbound-var
		    (assign unev (op object->string) (reg exp))
		    (assign val (op string-append)
			    (const "Error: accessing unbound variable: ")
			    (reg unev))
		    (goto (label signal-error))
	    \end{cscm}
	    For \vscm{set-variable-value!}, we modify \vscm{ev-assignment-1}:
	    \begin{cscm}
		ev-assignment-1
		    (restore continue)
		    (restore env)
		    (restore unev)
		    (assign val (op set-variable-value!) (reg unev) (reg val) (reg env))
		    (test (op eq?) (reg val) (const ,err-unbound-var))
		    (branch (label err-set-unbound-var))
		    (assign val (const ok))
		    (goto (reg continue))
		err-set-unbound-var
		    (assign unev (op object->string) (reg unev))
		    (assign val (op string-append)
			    (const "Error: setting unbound variable: ")
			    (reg unev))
		    (goto (label signal-error))
	    \end{cscm}
	    And lastly, for \vscm{extend-environment}, we modify 
	    \vscm{compound-apply}:
	    \begin{cscm}
		compound-apply
		    (assign unev (op procedure-parameters) (reg proc))
		    (assign env (op procedure-environment) (reg proc))
		    (assign env (op extend-environment) (reg unev) (reg argl) (reg env))
		    (test (op eq?) (reg env) (const ,err-arity))
		    (branch (label arity-error))
		    (assign unev (op procedure-body) (reg proc))
		    (goto (label ev-sequence))
		arity-error
		    (assign unev (op length) (reg unev))
		    (assign unev (op object->string) (reg unev))
		    (assign argl (op length) (reg argl))
		    (assign argl (op object->string) (reg argl))
		    (assign val (op string-append)
			    (const "Error in procedure applicatio: wrong number of arguments, expected ")
			    (reg unev) (const ", got ") (reg argl))
		    (goto (label signal-error))
	    \end{cscm}

	\item Instead of writing wrappers around each primitive procedure, 
	    replacing, for instance, \vscm{(list 'car car)} with
	    \vscm{(list 'car safe-car)} in \vscm{primitive-procedures}, 
	    I modified the representation of primitive procedures to include any 
	    number of checking procedures that are to be applied to the 
	    procedure’s arguments before the procedure is called. For instance, 
	    the definiton of \vscm{car} becomes:
	    \begin{cscm}
		(list 'car car (arity 1) (arg-type 0 pair?))
	    \end{cscm}
	    where \vscm{(arity 1)} and \vscm{(arg-type 0 pair?)} are procedures 
	    that will be defined later. All the new arguments added at the end 
	    of the list defining a given primitive procedure must be procedures 
	    that take the list of arguments we wish to apply the primitive 
	    procedure to as a parameter, they must return the boolean 
	    \vscm{true} (or \vscm{#t}) if the arguments pass the test, and 
	    a string with an error message if not.

	    We need a new accessor and a new definition of 
	    \vscm{primitive-procedure-objects}:
	    \scm{ch5/5.30b0.scm}
	    The following procedure tests the arguments with each checking 
	    procedure for the given procedure, and returns the first error, if 
	    any. If no error is found, it returns \vscm{true}.
	    \scm{ch5/5.30b1.scm}
	    It is called in the evaluator before applying a primitive procedure 
	    to the arguments: if an error is found, we go to 
	    \vscm{signal-error}, otherwise we can apply the procedure.
	    \begin{cscm}
		primitive-apply
		    (assign val (op check-primitive-arguments) (reg proc) (reg argl))
		    (test (op eq?) (reg val) (const #t))
		    (branch (label primitive-apply-1))
		    (assign unev (op object->string) (reg argl))
		    (assign val (op string-append)
			    (const "Error in primitive procedure application: ")
			    (reg val) (const "\nArguments: ") (reg unev))
		    (goto (label signal-error))
		primitive-apply-1
		    (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
		    (restore continue)
		    (goto (reg continue))
	    \end{cscm}
	    In a lot of cases, we only need to check the number or the type of 
	    the arguments, so we can define higher-order procedures that will be 
	    used by several primitive procedures. \vscm{(arity n)} returns 
	    a procedure that checks that the number of arguments is $n$, 
	    \vscm{pos-arity} checks that there is at least one argument, 
	    \vscm{(arg-type p test)} checks that the $p$-th argument (starting 
	    at 0) passes the given test (\vscm{test} could be any predicate in 
	    theory, but the error message assumes that it is a type predicate), 
	    and \vscm{(args-type test)} checks that all the arguments pass the 
	    test (same remark as for \vscm{arg-type}).

	    This could be improved by using memoization to save some space: lots 
	    of primitive procedures have the same arity or the same argument 
	    types, but the implementation shown below will return a new 
	    procedure object each time \vscm{(arity 1)} is called, for instance, 
	    though the same object could be used each time.
	    \scm{ch5/5.30b2.scm}
	    \vscm{Arg-type} uses \vscm{procedure-name} to retrieve the string 
	    \vscm{" pair"} when the \vscm{pair?} procedure is passed as 
	    a parameter, for instance. This implementation is specific to how 
	    Gambit Scheme displays procedures:
	    \scm{ch5/5.30b7.scm}
	    My list of primitive procedures includes \vscm{cddr}, \vscm{cadr}, 
	    etc., so I defined some specific checks for them:
	    \scm{ch5/5.30b3.scm}
	    Some range checks are needed for \vscm{substring} and 
	    \vscm{list-ref}:
	    \scm{ch5/5.30b4.scm}
	    \vscm{Assoc} needs an argument that is an association list:
	    \scm{ch5/5.30b5.scm}
	    The \vscm{/} procedure takes any positive number of arguments, and 
	    \vscm{(/ x)} is equivalent to \vscm{(/ 1 x)}, so to avoid divisions 
	    by zero we must treat the case where the number of arguments is 
	    1 differently. Another division by zero could happen in 
	    \vscm{remainder}.
	    \scm{ch5/5.30b6.scm}
	    And lastly, a part of the modified definition of 
	    \vscm{primitive-procedures}. I can’t guarantee that all the 
	    necessary checks are done…

	    While testing what error messages I got, I discovered that more 
	    procedures than what I expected can take any number of arguments, 
	    including none. This is for instance the case of \vscm{append}, 
	    \vscm{list}, \vscm{+} and \vscm{*}, who return respectively 
	    \vscm{()}, \vscm{()}, \vscm{0} and \vscm{1} when called with no 
	    argument. This is also the case of the comparison operators 
	    \vscm{=}, \vscm{<}, \vscm{>}, \vscm{<=}, \vscm{>=}, and others such 
	    as \vscm{string=?} etc. (but not \vscm{eq?} or \vscm{equal?}): with 
	    0 or 1 argument they return \vscm{true}, with more than 2 arguments 
	    they are applied to each successive pair of arguments, so that it’s 
	    possible to check that a list of numbers is sorted in non-decreasing 
	    order with
	    \vscm{(apply <= <list>)}.
	    \scm{ch5/5.30b8.scm}
    \end{enumerate}
\end{exe}

\section{Compilation}

\subsection{Structure of the Compiler}

\begin{exe}[5.31]
    \label{5.31}
    \ \vspace{-20pt}
    \begin{itemize}
        \item \vscm{(f 'x 'y)}: All the saves and restores are superfluous.
        \item \vscm{((f) 'x 'y)}: All the saves and restores are superfluous 
            because the arguments are quoted so \vscm{env} is not necessary for 
            their evaluation.
        \item \vscm{(f (g 'x) y)}: \vscm{proc} must be saved around the 
            evaluation of the operand sequence. \vscm{argl} must be saved around 
            the evaluation of \vscm{(g 'x)}. If the operands are evaluated 
            left-to-right, \vscm{env} must be saved around the evaluation of 
            \vscm{(g 'x)} so that the value of \vscm{y} can be retrieved. If 
            they are evaluated right-to-left\footnote{This is the case with the 
            code in the book, but we are not supposed to know that yet.}, no 
            further saves are needed.
        \item \vscm{(f (g 'x) 'y)}: This time the saves and restores are the 
            same no matter whether the operands are evaluated left-to-right or 
            right-to-left: as in the right-to-left case above, \vscm{proc} must 
            be saved around the evaluation of the operand sequence and 
            \vscm{argl} must be saved around the evaluation of \vscm{(g 'x)}.
    \end{itemize}
\end{exe}

\begin{exe}[5.32]
    \label{5.32}
    \ \vspace{-20pt}
    \begin{enumerate}
	\item In our evaluator, \vscm{variable?} is defined as \vscm{symbol?}, 
	    so we can replace the beginning of \vscm{ev-application} with:
            \begin{cscm}
                ev-application
                    (save continue)
                    (assign unev (op operands) (reg exp))
                    (assign exp (op operator) (reg exp))
                    (test (op variable?) (reg exp))
                    (branch (label symbol-operator))
                    (save env)
                    (save unev)
                    (assign continue (label ev-appl-did-operator))
                    (goto (label eval-dispatch))
                symbol-operator
                    (assign continue (label ev-appl-did-symbol-operator))
                    (goto (label ev-variable))
                ev-appl-did-operator
                    (restore unev)          ; the operands
                    (restore env)
                ev-appl-did-symbol-operator
                    (assign argl (op empty-arglist))
                ;; ... same as before
            \end{cscm}
            Since we know it is a variable, we could directly assign the result 
            of \vscm{lookup-variable-value} to \vscm{val}, but this would bypass 
            the error checking for unbound variables added in \autoref{5.30}.
        \item We could certainly recognize more special cases in the 
            interpreter, but this would make the interpreter much more complex, 
            which would mitigate, if not cancel out, the gains from the 
            optimizations. For instance, in the procedure application of the 
            previous exercise, we need to analyze all the arguments before 
            deciding whether it’s necessary to save \vscm{proc} before the 
            evaluation of the operand sequence, and when computing the value of 
            an argument we must analyze all the remaining arguments to decide 
            whether it’s necessary to preserve \vscm{env} and \vscm{argl}.

            Furthermore, as is explained at the beginning of the section, the 
            compiler’s optimizations regarding saves, restores, etc. are only 
            one of the reasons why compilation is more efficient. The other 
            reason is that each compiled expression is analyzed only once 
            whereas each interpreted expression is analyzed each time it is 
            evaluated. There is no way to incorporate this optimization into the 
            interpreter without compiling the expressions.
    \end{enumerate}
\end{exe}

\subsection{Compiling Expressions}

This subsection contains no exercises.

\subsection{Compiling Combinations}

This subsection contains no exercises.

\subsection{Compiling Instruction Sequences}

This subsection contains no exercises.

\subsection{An Example of Compiled Code}

\begin{exe}[5.33]
    With the first version, in the evaluation of the product, $n$ is evaluated 
    first and \vscm{argl} is preserved around the evaluation of
    \vscm{(factorial (- n 1))}. In the second version,
    \vscm{(factorial (- n 1))} is evaluated first and \vscm{env} is preserved 
    around its evaluation, but \vscm{argl} needs not be preserved. So both 
    program have the same efficiency.
\end{exe}

\begin{exe}[5.34]
    I won’t include the whole compiled code here, but the essential difference 
    lies in the generated code for the application of \vscm{factorial} (resp. 
    \vscm{iter}). With the recursive procedure, \vscm{(factorial (- n 1))} is 
    compiled with a linkage of \vscm{next} since it is an operand of \vscm{*}. 
    This means that before entering the procedure, it has to set up 
    \vscm{continue} so that \vscm{*} can be applied after the call. At that 
    point, the partial argument list for \vscm{*}, the procedure \vscm{*} 
    itself, and \vscm{continue} are on the stack, and they are restored only 
    after \vscm{(factorial (- n 1))} has returned, which happens after the same 
    data for the $n - 2$ following recursive calls has been put on the stack and 
    then removed as each call returned.
    \begin{cscm}
	;; apply factorial
	  (test (op primitive-procedure?) (reg proc))
	  (branch (label primitive-branch11))
	compiled-branch10
	  (assign continue (label after-call9))
	  (assign val (op compiled-procedure-entry) (reg proc))
	  (goto (reg val))
	;; Return point after the call:
	after-call9
	  (restore argl)
	  (assign argl (op cons) (reg val) (reg argl))
	  (restore proc)
	  (restore continue)
	;; Application of * after this.
    \end{cscm}
    With the iterative procedure,
    \vscm{(iter (* counter product) (+ counter 1))} is compiled with a linkage 
    of \vscm{return} because it is the last expression of the sequence. This is 
    a direct transfer, nothing is left on the stack that is needed to compute 
    the value of the original call to \vscm{iter}.
    \begin{cscm}
	;; Apply iter
	  (test (op primitive-procedure?) (reg proc))
	  (branch (label primitive-branch17))
	compiled-branch18
	  (assign val (op compiled-procedure-entry) (reg proc))
	  (goto (reg val))
    \end{cscm}
\end{exe}

\begin{exe}[5.35]
    The compiled expression was \vscm{(define (f x) (+ x (g (+ x 2))))}.
\end{exe}

\begin{exe}[5.36]
    The compiler produces code that evaluates the operands right-to-left. The 
    order is determined in \vscm{construct-arglist}, which reverses the codes for 
    the operands and then evaluates the operands starting from the last. We can 
    modify \vscm{construct-arglist} to evaluate the operands left-to-right as 
    shown below. The operand codes are not reversed, instead \vscm{argl} is 
    reversed at run-time after all the operands have been evaluated.

    The generated code is slower that the original version because the list has 
    to be reversed each time a procedure application is evaluated, whereas with 
    the right-to-left version the operand codes were reversed only once at 
    compile-time.

    Instead of reversing the argument list, it would have been possible to use 
    \vscm{adjoin-arg} instead of \vscm{cons} in \vscm{code-to-get-rest-args}, as 
    in the explicit-control evaluator, but this would have been less efficient 
    than reversing the list at the end.
    \scm{ch5/5.36.scm}
\end{exe}

\begin{exe}[5.37]
    To make \vscm{preserving} always generate the \vscm{save} and \vscm{restore} 
    operations, we only need to remove the code that checks whether the 
    registers to preserve are modified by the first sequence and needed by the 
    second sequence:
    \scm{ch5/5.37.scm}
    Let’s compare the compiled code for \vscm{(f 'x 'y)} (from \autoref{5.31}) 
    with the original \vscm{preserving}:
    \begin{cscm}
	    (assign proc (op lookup-variable-value) (const f) (reg env))
	    (assign val (const y))
	    (assign argl (op list) (reg val))
	    (assign val (const x))
	    (assign argl (op cons) (reg val) (reg argl))
	    (test (op primitive-procedure?) (reg proc))
	    (branch (label primitive-branch1))
	compiled-branch2
	    (assign continue (label after-call3))
	    (assign val (op compiled-procedure-entry) (reg proc))
	    (goto (reg val))
	primitive-branch1
	    (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
	after-call3
    \end{cscm}
    to the compiled code with the modified \vscm{preserving}:
    \begin{cscm}
	    (save continue)
	    (save env)
	    (save continue)
	    (assign proc (op lookup-variable-value) (const f) (reg env))
	    (restore continue)
	    (restore env)
	    (restore continue)
	    (save continue)
	    (save proc)
	    (save env)
	    (save continue)
	    (assign val (const y))
	    (restore continue)
	    (assign argl (op list) (reg val))
	    (restore env)
	    (save argl)
	    (save continue)
	    (assign val (const x))
	    (restore continue)
	    (restore argl)
	    (assign argl (op cons) (reg val) (reg argl))
	    (restore proc)
	    (restore continue)
	    (test (op primitive-procedure?) (reg proc))
	    (branch (label primitive-branch4))
	compiled-branch5
	    (assign continue (label after-call6))
	    (assign val (op compiled-procedure-entry) (reg proc))
	    (goto (reg val))
	primitive-branch4
	    (save continue)
	    (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
	    (restore continue)
	after-call6
    \end{cscm}
    No stack operation is needed for the evaluation of this expression, but the 
    modified version of \vscm{preserving} generates 10 saves and 10 restores for 
    this simple expression, and at two places it saves \vscm{continue} twice 
    when no operation other than \vscm{save}s has occurred in-between.
    For instance, the first time, it is because \vscm{compile-application} 
    preserves \vscm{env} and \vscm{continue} around the evaluation of the 
    procedure, and the procedure evaluation code is produced by 
    \vscm{compile-variable}, which uses \vscm{end-with-linkage}, which saves and 
    restores \vscm{continue} though the linkage is \vscm{next}.

    Even the compilation for a constant such as \vscm{2} has a \vscm{save} and 
    a \vscm{restore} with the modified \vscm{preserving}. This comes from 
    \vscm{end-with-linkage}.
\end{exe}

\begin{exe}[5.38]
    \label{5.38}
    \ \vspace{-20pt}
    \begin{enumerate}
	\item It’s not very clear from the text whether \vscm{spread-arguments} 
	    is supposed to work for only two arguments or more, but with only 
	    the operands as a parameter and not the native operation to apply 
	    it’s not really possible to do something useful for more than two 
	    arguments. Since the Scheme procedures \vscm{=}, \vscm{+} and 
	    \vscm{*} take 0 or more arguments and \vscm{-} and \vscm{/} one or 
	    more, I wrote a procedure that assumes that there are at most two 
	    arguments.

	    If there is no argument, it returns the empty instruction sequence.
	    If there is one argument, it returns code to evaluate it and put its 
	    value in \vscm{arg1}.
	    If there are two arguments, it returns code to put the first one in 
	    \vscm{arg1} and the second one in \vscm{arg2}. \vscm{arg1} must be 
	    preserved around the evaluation of the second argument. Since I know 
	    that \vscm{arg1} will be needed after the evaluation of the 
	    arguments, I used an instruction sequence with no statements to 
	    force \vscm{preserving} to save \vscm{arg1} if it is modified during 
	    the computation of \vscm{arg2}.
	    \scm{ch5/5.38a.scm}

	\item We can use the same code generator for all the open-coded 
	    primitives we currently have:
	    \scm{ch5/5.38b.scm}
	    The compilation procedure checks the arity, but the other checks 
	    added in \autoref{5.30}, for the arguments’ type and for division by 
	    zero, are not done here because they can’t be done at compile-time.

	    Then we just have to add the following line to the dispatch in the 
	    compiler:
	    \begin{cscm}
		((native-op? exp) (compile-native-op exp target linkage))
	    \end{cscm}

	    The \vscm{arg1} and \vscm{arg2} registers must be added to 
	    \vscm{all-args}, otherwise, when compiling code such as:
	    \begin{cscm}
		(define (f x) (* 2 x))
		(define (g x) (+ 3 (f x)))
	    \end{cscm}
	    the compiler does not detect that the evaluation of \vscm{(f x)} 
	    modifies \vscm{arg1}, so \vscm{(g x)} returns $2x + 2$ instead of
	    $2x + 3$.

	\item The compiled code for \vscm{factorial} is much shorter than the 
	    result produced without open coding:
	    \begin{cscm}
		    (assign val (op make-compiled-procedure) (label entry1) (reg env))
		    (goto (label after-lambda2))
		entry1
		    (assign env (op compiled-procedure-env) (reg proc))
		    (assign env (op extend-environment) (const (n)) (reg argl) (reg env))
		    (assign arg1 (op lookup-variable-value) (const n) (reg env))
		    (assign arg2 (const 1))
		    (assign val (op =) (reg arg1) (reg arg2))
		    (test (op false?) (reg val))
		    (branch (label false-branch4))
		true-branch3
		    (assign val (const 1))
		    (goto (reg continue))
		false-branch4
		    (save continue)
		    (save env)
		    (assign proc (op lookup-variable-value) (const factorial) (reg env))
		    (assign arg1 (op lookup-variable-value) (const n) (reg env))
		    (assign arg2 (const 1))
		    (assign val (op -) (reg arg1) (reg arg2))
		    (assign argl (op list) (reg val))
		    (test (op primitive-procedure?) (reg proc))
		    (branch (label primitive-branch6))
		compiled-branch7
		    (assign continue (label proc-return9))
		    (assign val (op compiled-procedure-entry) (reg proc))
		    (goto (reg val))
		proc-return9
		    (assign arg1 (reg val))
		    (goto (label after-call8))
		primitive-branch6
		    (assign arg1 (op apply-primitive-procedure) (reg proc) (reg argl))
		after-call8
		    (restore env)
		    (assign arg2 (op lookup-variable-value) (const n) (reg env))
		    (assign val (op *) (reg arg1) (reg arg2))
		    (restore continue)
		    (goto (reg continue))
		after-if5
		after-lambda2
		    (perform (op define-variable!) (const factorial) (reg val) (reg env))
		    (assign val (const ok))
	    \end{cscm}

	\item I started to modify \vscm{spread-arguments} so that it would take 
	    the operation to be applied as a parameter and handle any number of 
	    arguments by accumulating them in \vscm{arg1} successively. But then 
	    I noticed that:
	    \begin{itemize}
		\item This approach does not work if I also want to generalize 
		    \vscm{=} to any number of arguments, though this is not 
		    asked in the text.
		\item For \vscm{+}, \vscm{-}, \vscm{*} and \vscm{/}, it’s easier 
		    to just rewrite the expressions so that \vscm{(+ a b c)} 
		    becomes \vscm{(+ (+ a b) c)}.
	    \end{itemize}

	    So I divided the native procedures into two sets:
	    \begin{itemize}
		\item \vscm{+}, \vscm{-}, \vscm{*} and \vscm{/} are numeric 
		    procedures for which the above transformation can be done.
		\item Expressions with \vscm{=}\footnote{And the other 
		    comparison procedures that take any number of arguments: 
		    \vscm{<}, \vscm{>}…} are instead transformed in \vscm{and} 
		    expressions if they have more than two arguments: for 
		    instance\vscm{(= a b c)} becomes
		    \vscm{(and (= a b) (= a c))}.
	    \end{itemize}
	    The \vscm{compile-native-num-op} procedure applies to the first set, 
	    it transforms the expression it receives so that it does not have 
	    more that two arguments and calls \vscm{compile-native-op} from 
	    point b to compile it.

	    The \vscm{compile-native-comp-op} procedure calls 
	    \vscm{compile-native-op} if there are at most two arguments, 
	    otherwise it transforms the expression into an \vscm{and} expression 
	    and calls \vscm{compile}.
	    \scm{ch5/5.38d.scm}
    \end{enumerate}
\end{exe}

\subsection{Lexical Addressing}

\begin{exe}[5.39]
    The \vscm{lexical-address-lookup} and \vscm{lexical-address-set!} procedures 
    can be defined as shown below.
    \scm{ch5/5.39.scm}
\end{exe}

\begin{exe}[5.40]
    All the \vscm{compile-...} procedures (except \vscm{compile-self-evaluating} 
    and \vscm{compile-quoted}) must be modified to pass around the new argument, 
    I’m not including the code here. In \vscm{compile-lambda-body}, the 
    compile-time environment is extended with the formals:
    \scm{ch5/5.40.scm}
\end{exe}

\begin{exe}[5.41]
    We can define \vscm{find-variable} as follows:
    \scm{ch5/5.41.scm}
\end{exe}

\begin{exe}[5.42]
    Here are the new versions of \vscm{compile-variable} and 
    \vscm{compile-assignment}. If the variable is not found in the compile-time 
    environment, the \vscm{env} register is modified so it must be added to the 
    list of modified registers.
    \scm{ch5/5.42.scm}
\end{exe}

\begin{exe}[5.43]
    We can call \vscm{scan-out-defines} in \vscm{compile-lambda-body}, or 
    redefine \vscm{lambda-body} so it calls \vscm{scan-out-defines}, which will 
    also affect the interpreter of course.
    \scm{ch5/5.43.scm}
\end{exe}

\begin{exe}[5.44]
    We can pass the compile-time environment to the \vscm{native-num-op?} and 
    \vscm{native-comp-op?} predicates so that they check whether the names have 
    been rebound.
    \scm{ch5/5.44.scm}
\end{exe}

\subsection{Interfacing Compiled Code to the Evaluator}

\begin{exe}[5.45]
    \ \vspace{-20pt}
    \begin{enumerate}
	\item The table below shows the number of pushes and the maximum depth 
	    for the special-purpose machine, the interpreter, the compiler 
	    without optimizations from \autoref{5.32} (case where the procedure 
	    is a variable) and \autoref{5.38} (open-coding of some primitives) 
	    and the optimized compiler.
	    \begin{center}
		\begin{tabular}{|c|c|c|}
		    \hline
		    & Maximum depth & Number of pushes \\\hline
		    Evaluator & $5n + 3$ & $32n - 16$ \\\hline
		    Compiler with no optimizations & $3n - 1$ & $6n + 1$ \\\hline
		    Compiler with optimizations & $2n - 2$ & $2n + 1$\\\hline
		    Special-purpose machine & $2n - 2$ & $2n - 2$ \\\hline
		\end{tabular}
	    \end{center}
	    The table below shows the limits of the ratios for the various 
	    versions.
	    \begin{center}
		\begin{tabular}{|c|c|c|}
		    \hline
		    & Maximum depth & Number of pushes \\\hline
		    Interpreted / Compiled, non optimized & $1.66…$ & $5.33…$ \\\hline
		    Interpreted / Compiled, optimized & $2.5$ & $16$ \\\hline
		    Interpreted / Special-purpose & $2.5$ & $16$ \\\hline
		    Compiled, non optimized / Special-purpose & $1.5$ & $3$ \\\hline
		    Compiled, optimized / Special-purpose & $1$ & $1$ \\\hline
		\end{tabular}
	    \end{center}
	\item With the optimizations turned on, the generated code for the 
	    procedure contains just one save of \vscm{continue} and one save 
	    of \vscm{env} before each recursive call, just like the 
	    hand-tailored version. Invoking the compiled procedure causes three 
	    additional pushes compared to the hand-tailored version, but they 
	    come from the interpreter: \vscm{continue} is saved at 
	    \vscm{ev-application}, \vscm{proc} is saved at 
	    \vscm{ev-appl-did-symbol-operator}, and \vscm{argl} is saved at 
	    \vscm{ev-appl-operand-loop}. So at least regarding stack usage, it’s 
	    not possible to improve the compiler here.

	    The compiled code has more instructions than the hand-tailored 
	    version because the compiler generates code that can handle general 
	    application of primitive or compiled procedures using environments 
	    and argument lists, and I don’t really see how to improve the 
	    compiler here either.
    \end{enumerate}
\end{exe}

\begin{exe}[5.46]
    The table below gives the maximum depth and the number of pushes for the 
    computation of the Fibonacci numbers with the tree-recursive procedure. The 
    special purpose machine from the book actually does more stack pushes than 
    the optimized compiled version, which is as good as the hand-tailored 
    machine with the optimization of \autoref{5.6}\footnote{As in the previous 
    exercise, the three additional pushes come from the interpreter.}.

    The formulas for the number of pushes were determined with the same method 
    as in \autoref{5.29}.
    \begin{center}
	\begin{tabular}{|c|c|c|}
	    \hline
	    & Maximum depth & Number of pushes \\\hline
	    Evaluator & $5n + 3$ & $56 \Fib(n + 1) - 40$ \\\hline
	    Compiler with no optimizations & $3n - 1$ & $10 \Fib(n + 1) - 3$ \\\hline
	    Compiler with optimizations & $2n - 2$ & $3 \Fib(n + 1)$ \\\hline
	    Special-purpose machine & $2n - 2$ & $4 \Fib(n + 1) - 4$ \\\hline
	    Special-purpose machine, \ref{5.6} & $2n - 2$ & $3 \Fib(n + 1) - 3$ \\\hline
	\end{tabular}
    \end{center}
    The table below shows the limits of the ratios for the various versions. 
    Contrary to what the text says, the ratios of stack operations do approach 
    a constant because the formulas are all linear in $\Fib(n + 1)$. For 
    instance:
    \[
    \frac{56 \Fib(n + 1) - 40}{10 \Fib(n + 1) - 3} =
	\frac{56 - \sfrac{40}{\Fib(n + 1)}}{10 - \sfrac{3}{\Fib(n + 1)}}
    \]
    which has limit $\sfrac{56}{10} = 5.6$ when $n$ tends to infinity.
    \begin{center}
	\begin{tabular}{|c|c|c|}
	    \hline
	    & Maximum depth & Number of pushes \\\hline
	    Interpreted / Compiled, non optimized & $1.66…$ & $5.6$ \\\hline
	    Interpreted / Compiled, optimized & $2.5$ & $18.66…$ \\\hline
	    Interpreted / Special-purpose & $2.5$ & $14$ \\\hline
	    Interpreted / Special-purpose, \ref{5.6} & $2.5$ & $18.66…$ \\\hline
	    Compiled, non optimized / Special-purpose & $1.5$ & $2.5$ \\\hline
	    Compiled, non optimized / Special-purpose, \ref{5.6} & $1.5$ & $3.33…$ \\\hline
	    Compiled, optimized / Special-purpose & $1$ & $0.75$ \\\hline
	    Compiled, optimized / Special-purpose, \ref{5.6} & $1$ & $1$ \\\hline
	\end{tabular}
    \end{center}
\end{exe}

\begin{exe}[5.47]
    In \vscm{compile-procedure-call}, we add a test for compound procedures and 
    a third parallel sequence to the generated code. The code for the procedure 
    application is generated by \vscm{compile-compound-proc-appl}, which is very 
    similar to \vscm{compile-proc-appl}. At \vscm{compound-apply}, the 
    continuation point is expected to be on the stack, so \vscm{continue} must 
    be saved before going to \vscm{compound-apply}.
    \scm{ch5/5.47.scm}
\end{exe}

\begin{exe}[5.48]
    The \vscm{compile-and-run} primitive can be defined similarly to 
    \vscm{compile-and-go}. The only difference is that it does not set the 
    global environment because that would delete all the definitions previously 
    entered in the interpreter.
    \scm{ch5/5.48.scm}
\end{exe}

\begin{exe}[5.49]
    The only change needed is to replace the following line in 
    \vscm{read-eval-print-loop}:
    \begin{cscm}
	(goto (label eval-dispatch))
    \end{cscm}
    with the following two lines:
    \begin{cscm}
	(assign val (op compile-and-assemble) (reg exp))
	(goto (reg val))
    \end{cscm}
    With \vscm{compile-and-assemble} defined as:
    \scm{ch5/5.49.scm}
\end{exe}

\begin{exe}[5.50]
    The biggest difficulty is to not confuse the different levels of execution. 
    In particular, there are now three lists of primitive operations:
    \begin{enumerate}[label=\arabic{enumi}.]
        \item \vscm{eceval-operations} defines the operations that may be used 
            as register-machine operations, in \vscm{(assign ... (op ...) ...)} 
            or
            \vscm{(perform (op ...) ...)} expressions. In an element of this 
            list such as \vscm{(list 'length length)}, the \vscm{length} 
            procedure is that of the underlying Scheme implementation used to 
            run the register machine.
	\item The \vscm{primitive-procedures} list defined when implementing the 
	    explicit-control evaluator, and also used by the compiler, defines 
	    the procedures considered as primitives in any program running in 
	    the explicit-control evaluator (interpreted or compiled). As for the 
	    first case, when this list contains an element such as
	    \vscm{(list 'length length)}, the \vscm{length} procedure is that of 
	    the underlying Scheme implementation used to run the register 
	    machine. The primitive procedures of this list need not belong to 
	    the previous list\footnote{Except for the open-coded primitives.} 
	    because they are applied with \vscm{apply-primitive-procedure}, 
	    which belongs to the previous list.
	\item The metacircular evaluator also defines a list of primitive 
	    procedures. They refer to the underlying Scheme implementation, 
	    which is this time the explicit-control evaluator and not the Scheme 
	    interpreter running still underneath it. This means that the 
	    primitives defined there must be primitives for the explicit-control 
	    evaluator.

	    For instance, if I add a new primitive to the explicit-control 
	    evaluator:
	    \begin{cscm}
		(list 'iszero? (lambda (x) (= x 0)))
	    \end{cscm}
	    The new \vscm{iszero?} procedure can be used in the explicit-control 
	    evaluator, in particular in the procedures used to define the 
	    metacircular evaluator, and if I add the line:
	    \begin{cscm}
		(list 'zero? iszero?)
	    \end{cscm}
	    to the primitive procedures of the compiled metacircular evaluator, 
	    \vscm{zero?} can be used in the driver-loop of this interpreter, but 
	    not in the explicit-control evaluator.
    \end{enumerate}
    Because the metacircular evaluator is now defined as a program running in 
    the explicit-control evaluator, the Scheme procedures it uses must be added 
    to the primitives of the explicit-control evaluator if they are not there 
    yet: \vscm{caadr}, \vscm{cdadr}, \vscm{cdddr}, \vscm{cadddr}, 
    \vscm{set-car!}, \vscm{set-cdr!}, \vscm{string?}, \vscm{true?} and 
    \vscm{false?} must be added.

    Several procedures used to implement the metacircular evaluator use 
    \vscm{map}, but that procedure must first be redefined because the 
    procedures to apply are now compiled or compound procedures and not 
    procedures for the underlying Scheme implementation, so \vscm{map} can’t be 
    used as a primitive (see \autoref{4.14}).

    The last notable change needed is for \vscm{apply-primitive-procedure}: the 
    evaluator from \secref{4.1} used the \vscm{apply} procedure from the 
    underlying Scheme by defining:
    \begin{cscm}
	(define apply-in-underlying-scheme apply)
    \end{cscm}
    The same works here provided that \vscm{apply} is a primitive of the 
    explicit-control evaluator, but since the procedures to apply are primitive 
    procedures of the explicit-control evaluator and not Scheme procedures, it 
    must use \vscm{apply-primitive-procedure} and not \vscm{apply}, i.e. the 
    second list in the above enumeration has
    \begin{cscm}
	(list 'apply apply-primitive-procedure)
    \end{cscm}
\end{exe}
