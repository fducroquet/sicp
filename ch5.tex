\chapter{Computing with Register Machines}

\section{Designing Register Machines}

\begin{exe}[5.1]
    \label{5.1}
    The data-path and the controller diagrams for the iterative factorial 
    machine are shown on figure~\ref{5.1fig}.

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            % Data-path diagram.
            \matrix[data matrix] (dp) {
                & \node[reg] (n) {n}; &
                \node[test] (>) {>}; \\

                & \node[const] (c1) {1}; & \\

                \node[reg] (p) {product}; &&
                \node[reg] (c) {counter}; \\

                & \node[op] (+) {+}; & \\

                & \node[op] (*) {*}; & \\
            };

            \draw[arg] (n) -- (>);
            \draw[arg] (c) -- (>);
            \draw[button=0.82] (c1) -| node[near start, above] {p<-1} (p);
            \draw[button=0.82] (c1) -| node[near start, above] {c<-1}
                ($ (c.north) + (-1em, 0) $);
            \draw[arg] (c1) -- (+);
            \draw[button=0.8] ($ (+.north) + (1em, 0) $) |-
                node[near end, above] {c++} (c);
            \draw[arg] (c) |- (+);
            \draw[arg] ($ (p.south) + (-1em, 0) $) |-
                ($ (*.south) + (0, -1.5em) $) -- (*);
            \draw[arg] (c) |- (*);
            \draw[button=0.8] (*) -| node[near end, right]{p<-*}
                ($ (p.south) + (1em, 0) $);

            % Controller diagram
            \matrix[controller matrix, right=5em of dp] {
                \node[cio] (s) {start}; \\
                \node[cbutton] (pi) {p<-1}; \\
                \node[cbutton] (ci) {c<-1}; \\
                \node[ctest] (ct) {>}; & \node[cio] (cd) {done}; \\[+1em]
                \node[cbutton] (cp) {p<-*}; \\
                \node[cbutton] (cc) {c++}; \\
            };

            \draw[flow] (s) -- (pi);
            \draw[flow] (pi) -- (ci);
            \draw[flow] (ci) -- (ct);
            \draw[flow] (ct) --node[right] {no} (cp);
            \draw[flow] (ct) --node[above] {yes} (cd);
            \draw[flow] (cp) -- (cc);
            \draw[flow] (cc) -| ($ (ct.west) - (2.5em, 0) $) -- (ct);
        \end{tikzpicture}
        \caption{The data-path and controller diagrams for the iterative 
        factorial machine.}
        \label{5.1fig}
    \end{figure}
\end{exe}

\subsection{A Language for Describing Register Machines}

\begin{exe}[5.2]
    Anticipating on the next section to use the register-machine simulator, we 
    can define the iterative factorial machine of exercise~\ref{5.1} as:
    \scm{ch5/5.02.scm}
\end{exe}

\subsection{Abstraction in Machine Design}

\begin{exe}[5.3]
    Using the simulator again, the first version of the register machines can be 
    defined as:
    \scm{ch5/5.03a.scm}
    and the second version as:
    \scm{ch5/5.03b.scm}
    The data-path diagrams are shown on figures~\ref{5.03afig} 
    and~\ref{5.03bfig} respectively.

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix] {
                \node[const] (c1) {1};
                &[+1em] \node[reg] (g) {guess};
                & \node[test] (ge) {g-e?};
                & \node[reg] (x) {x}; \\

                && \node[op] (i) {improve}; \\
            };

            \draw[button=.5] (c1) -- (g);
            \draw[arg] (g) -- (ge);
            \draw[arg] (x) -- (ge);
            \draw[arg] ($ (g.south) + (1em, 0) $) |- (i);
            \draw[button=.7] (i.south) -- ($ (i.south) - (0, 1em) $) -|
                ($ (g.south) - (1em, 0) $);
            \draw[arg] (x) |- (i);
        \end{tikzpicture}
        \caption{The data-path diagram for the square root machine using complex 
        primitive operations.}
        \label{5.03afig}
    \end{figure}

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix, matrix of nodes, nodes in empty cells]
            (table) {%
                && \node[const] (c1) {1};
                & \node[op] (div2) {/};
                & \node[const] (c2) {2}; \\

                &&& \node[minimum height=1.5\regheight] {guess}; &&& \\

                && \node[op] (divx) {/};
                & \node[op] (*) {*};
                & \node[op] (+) {+}; \\

                & \node[reg] (x) {x};
                && \node {tmp};
                && \node[test] (<eps) {<};
                & \node[const, inner xsep = -.2em] (eps) {0.001}; \\

                && \node[op] (mx) {-};
                & \node[op] (mtmp) {-};
                & \node[test] (>0) {<};
                & \node[const] (c0) {0}; \\
            };
            \begin{scope}[on background layer]
                \node[reg, fit=(table-2-3)(table-2-5)] (guess) {};
                \node[reg, fit=(table-4-3)(table-4-5)] (tmp) {};
            \end{scope}

            \draw[button=.6] (c1) -- (guess.north -| c1);
            \draw[arg] ($ (guess.north) - (3em, 0) $) |- (div2);
            \draw[arg] (c2) -- (div2);
            \draw[button=.6] (div2) -- (guess);
            \draw[arg] (x) |- (divx);
            \draw[arg] (guess.south -| divx) -- (divx);
            \draw[button=.6] (divx) -- (tmp.north -| divx.south);
            \draw[arg] ($ (guess.south) - (1em, 0) $) --
                ($ (*.north) - (1em, 0) $);
            \draw[arg] ($ (guess.south) + (1em, 0) $) --
                ($ (*.north) + (1em, 0) $);
            \draw[button=.6] (*) -- (tmp);
            \coordinate (pc) at (guess.south -| +.north);
            \draw[arg] ($ (pc) - (1em, 0) $) -- ($ (+.north) - (1em, 0) $);
            \draw[button=.6] ($ (+.north) + (1em, 0) $) -- ($ (pc) + (1em, 0) $);
            \draw[arg] (tmp.north -| +) -- (+);
            \draw[arg] (tmp) -- (<eps);
            \draw[arg] (eps) -- (<eps);
            \draw[arg] (x) |- (mx);
            \coordinate (mc) at (tmp.south -| mx.north);
            \draw[arg] ($ (mc) - (1em, 0) $) -- ($ (mx.north) - (1em, 0) $);
            \draw[button=.6] ($ (mx.north) + (1em, 0) $) --
                ($ (mc) + (1em, 0) $);
            \draw[arg] ($ (tmp.south) - (1em, 0) $) --
                ($ (mtmp.north) - (1em, 0) $);
            \draw[button=.6] ($ (mtmp.north) + (1em, 0) $) --
                ($ (tmp.south) + (1em, 0) $);
            \draw[arg] (tmp.south -| >0) -- (>0);
            \draw[arg] (c0) -- (>0);
        \end{tikzpicture}
        \caption{The data-path diagram for the square root machine using only 
        basic primitive operations.}
        \label{5.03bfig}
    \end{figure}
\end{exe}

\subsection{Subroutines}

This subsection contains no exercises.

\subsection{Using a Stack to Implement Recursion}

\begin{exe}[5.4]
    \label{5.04}
    \ \vspace{-20pt}
    \begin{enumerate}
	\item The recursive exponentiation machine can be defined as follows. 
	    The corresponding data-path diagram is shown on figure~\ref{5.04afig}.
            \scm{ch5/5.04a.scm}
	\item The iterative exponentiation machine can be defined as follows. 
	    The corresponding data-path diagram is shown on 
	    figure~\ref{5.04bfig}.
            \scm{ch5/5.04b.scm}
    \end{enumerate}

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix] {
                \node[const] (c0) {0};
                & \node[test] (=) {=};
                & \node[reg] (n) {n};
                &[+1em] &[-4.5em] \node[reg] (stack) {stack}; \\

                \node[const] (c1) {1};
                & \node[op] (-) {-};
                &&& \node[reg] (continue) {continue};
                &[-4.5em]& \node (controller) {controller}; \\

                \node[reg] (val) {val};
                & \node[op] (*) {*};
                & \node[reg] (b) {b};
                & \node[const, inner xsep=-.2em] (ed) {e-d};
                && \node[const, inner xsep=-.2em] (ae) {a-e}; \\
            };

            \draw[arg] (c0) -- (=);
            \draw[arg] (n) -- (=);
            \draw[button=.5] ($ (n.east) + (0, .7em) $) --
                ($ (stack.west) + (0, .7em) $);
            \draw[button=.5] ($ (stack.west) - (0, .7em) $) --
                ($ (n.east) - (0, .7em) $);
            \draw[arg] (c1) -- (-);
            \draw[arg] ($ (n.south) - (.7em, 0) $) |- (-);
            \draw[button=.8] (-) -- ($ (-.south) - (0, 1em) $)
                -| ($ (n.south) + (.7em, 0) $);
            \draw[button=.5] ($ (stack.south) - (.7em, 0) $) --
                ($ (continue.north) - (.7em, 0) $);
            \draw[button=.5] ($ (continue.north) + (.7em, 0) $) --
                ($ (stack.south) + (.7em, 0) $);
            \draw[arg] (continue) -- (controller);
            \draw[arg] (c1) -- (val);
            \draw[arg] (val) -- (*);
            \draw[button=.7] (*) -- ($ (*) - (0, 3em) $) -| (val);
            \draw[arg] (b) -- (*);
            \draw[button=.5] (ed) -- (ed |- continue.south);
            \draw[button=.5] (ae) -- (ae |- continue.south);
        \end{tikzpicture}
        \caption{The data-path diagram for the recursive exponentiation 
        machine.}
        \label{5.04afig}
    \end{figure}

    \begin{figure}
        \centering
        \begin{tikzpicture}[>=Stealth]
            \matrix[data matrix] {
                \node[reg] (b) {b};
                & \node[const] (c0) {0};
                &[+1em] \node[op] (=) {=}; \\

                \node[op] (*) {*};
                & \node[reg] (n) {n};
                & \node[reg] (c) {counter}; \\

                \node[reg] (p) {product};
                & \node[const] (c1) {1};
                & \node[op] (-) {-}; \\
            };

            \draw[arg] (c0) -- (=);
            \draw[arg] (c) -- (=);
            \draw[arg] (b) -- (*);
            \draw[arg] ($ (p.north) - (.7em, 0) $) --
                ($ (*.south) - (.7em, 0) $);
            \draw[button=.5] ($ (*.south) + (.7em, 0) $) --
                ($ (p.north) + (.7em, 0) $);
            \draw[button=.5] (n) -- (c);
            \draw[arg] (c1) -- (p);
            \draw[arg] (c1) -- (-);
            \draw[arg] ($ (c.south) - (1em, 0) $) --
                ($ (-.north) - (1em, 0) $);
            \draw[button=.5] ($ (-.north) + (1em, 0) $) --
                ($ (c.south) + (1em, 0) $);
        \end{tikzpicture}
        \caption{The data-path diagram for the iterative exponentiation 
        machine.}
        \label{5.04bfig}
    \end{figure}
\end{exe}

\begin{exe}[5.5]
    The following table lists the instructions evaluated during the simulation 
    of factorial 3, with their effect on the values of the registers \vscm{n}, 
    \vscm{val}, and \vscm{continue} and on the stack.
    \begin{longtable}{|l|c|c|c|c|}
        \hline
        \bfseries Instruction & \bfseries n & \bfseries val & \bfseries continue 
        & \bfseries stack \\\hline
        \endhead
        (assign cont (label fact-done)) & 3 & *unassigned* & fact-done & () 
        \\\hline
        (test (op =) ...) -> false &&&& \\\hline
        (branch (label base-case)) &&&& \\\hline
        (save continue) &&&& (fact-done) \\\hline
        (save n) &&&& (3 fact-done) \\\hline
        (assign n (op -) ...) & 2 &&& \\\hline
        (assign cont (label after-fact)) &&& after-fact & \\\hline
        (goto (label fact-loop)) &&&& \\\hline
        (test (op =) ...) -> false &&&& \\\hline
        (branch (label base-case)) &&&& \\\hline
        (save cont) &&&& (after-fact 3 fact-done) \\\hline
        (save n) &&&& (2 after-fact 3 fact-done) \\\hline
        (assign n (op -) ...) & 1 &&& \\\hline
        (assign cont (label after-fact)) &&& after-fact & \\\hline
        (goto (label fact-loop)) &&&& \\\hline
        (test (op =) ...) -> true &&&& \\\hline
        (branch (label base-case)) &&&& \\\hline
        (assign val (const 1)) && 1 && \\\hline
        (goto (reg cont)) -> after-fact &&&& \\\hline
        (restore n) & 2 &&& (after-fact 3 fact-done) \\\hline
        (restore cont) &&& after-fact & (3 fact-done) \\\hline
        (assign val (op *) ...) && 2 && \\\hline
        (goto (reg cont)) -> after-fact &&&& \\\hline
        (restore n) & 3 &&& (fact-done) \\\hline
        (restore cont) &&& fact-done & () \\\hline
        (assign val (op *) ...) && 6 && \\\hline
        (goto (reg cont)) -> fact-done &&&& \\\hline
    \end{longtable}

    The following table lists the instructions evaluated during the simulation 
    of fibonacci 3, with their effect on the values of the registers \vscm{n}, 
    \vscm{val}, and \vscm{continue} and on the stack.
    \begin{longtable}{|l|c|c|c|c|}
        \hline
        \bfseries Instruction & \bfseries n & \bfseries val & \bfseries continue 
        & \bfseries stack \\\hline
        \endhead
        (assign cont (label fib-done) & 3 & *unassigned* & fib-done & () 
        \\\hline
        (test (op <) ...) -> false &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (save cont) &&&& (fib-done) \\\hline
        (assign cont (label after-fib-n-1)) &&& after-fib-n-1 & \\\hline
        (save n) &&&& (3 fib-done) \\\hline
        (assign n (op -) ...1) & 2 &&& \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> false &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (save cont) &&&& (after-fib-n-1 3 fib-done) \\\hline
        (assign cont (label after-fib-n-1)) &&& after-fib-n-1 & \\\hline
        (save n) &&&& (2 after-fib-n-1 3 fib-done) \\\hline
        (assign n (op -) ...1) & 1 &&& \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> true &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (assign val (reg n)) && 1 && \\\hline
        (goto (reg cont)) -> after-fib-n-1 &&&& \\\hline
        (restore n) & 2 &&& (after-fib-n-1 3 fib-done) \\\hline
        (restore cont) &&& after-fib-n-1 & (3 fib-done) \\\hline
        (assign n (op -) ...2) & 0 &&& \\\hline
        (save cont) &&&& (after-fib-n-1 3 fib-done) \\\hline
        (assign cont (label after-fib-n-2)) &&& after-fib-n-2 & \\\hline
        (save val) &&&& (1 after-fib-n-1 3 fib-done) \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> true &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (assign val (reg n)) && 0 && \\\hline
        (goto (reg cont)) -> after-fib-n-2 &&&& \\\hline
        (assign n (reg val)) & 0 &&& \\\hline
        (restore val) && 1 && (after-fib-n-1 3 fib-done) \\\hline
        (restore cont) &&& after-fib-n-1 & (3 fib-done) \\\hline
        (assign val (op +) ...) && 1 && \\\hline
        (goto (reg cont)) -> after-fib-n-1 &&&& \\\hline
        (restore n) & 3 &&& (fib-done) \\\hline
        (restore cont) &&& fib-done & () \\\hline
        (assign n (op -) ... 2) & 1 &&& \\\hline
        (save cont) &&&& (fib-done) \\\hline
        (assign cont (label after-fib-n-2)) &&& after-fib-n-2 & \\\hline
        (save val) &&&& (1 fib-done) \\\hline
        (goto (label fib-loop)) &&&& \\\hline
        (test (op <) ...) -> true &&&& \\\hline
        (branch (label imm-answer)) &&&& \\\hline
        (assign val (reg n)) && 1 && \\\hline
        (goto (reg cont)) -> after-fib-n-2 &&&& \\\hline
        (assign n (reg val)) & 1 &&& \\\hline
        (restore val) && 1 && (fib-done) \\\hline
        (restore cont) &&& fib-done & () \\\hline
        (assign val (op +) ...) && 2 && \\\hline
        (goto (reg cont)) -> fib-done &&&& \\\hline
    \end{longtable}
\end{exe}

\begin{exe}[5.6]
    In \vscm{after-fib-n-1}, the instructions \vscm{(restore continue)} and 
    \vscm{(save continue)} can be removed because no change is done to the 
    \vscm{continue} register or to the stack between them.
\end{exe}

\subsection{Instruction Summary}

This subsection contains no exercises.

\section{A Register-Machine Simulator}

\begin{exe}[5.7]
    Already done while doing exercise~\ref{5.04}.
\end{exe}

\subsection{The Machine Model}

This subsection contains no exercises.

\subsection{The Assembler}

\begin{exe}[5.8]
    With the simulator as written, the contents of register \vscm{a} will be 3: 
    two labels with the name \vscm{here} are present in the list of labels, but 
    the one corresponding to the first location comes first and is the one 
    returned by \vscm{lookup-label}.

    We can return an error if the same label name is used to indicate two 
    different locations by modifying \vscm{extract-labels} as follows:
    \scm{ch5/5.08.scm}
\end{exe}

\subsection{Generating Execution Procedures for Instructions}

\begin{exe}[5.9]
    We can forbid labels as arguments to operations by adding a test to the 
    \vscm{make-operation-exp} procedure:
    \scm{ch5/5.09.scm}
\end{exe}

\begin{exe}[5.10]
    I only modified the syntax of \vscm{op}, for instance
    \vscm{(assign <reg-name> (op <op-name>) <args>)} becomes
    \vscm{(assign <reg-name> op <op-name> <args>)}:
    \scm{ch5/5.10.scm}
\end{exe}

\begin{exe}[5.11]
    \ \vspace{-20pt}
    \begin{enumerate}
	\item After the label \vscm{after-fib-n-2}, the last value placed on the 
	    stack is $\Fib(n - 1)$, and the \vscm{val} register contains $\Fib(n 
	    - 2)$. The Fibonacci machine places $\Fib(n - 2)$ in the \vscm{n} 
	    register before restoring the last saved value in the \vscm{val} 
	    register. We can instead restore the last saved value in the 
	    \vscm{n} register and remove an assignment operation. So the lines:
            \begin{cscm}
                (assign n (reg val))
                (restore val)
            \end{cscm}
            become:
            \begin{cscm}
                (restore n)
            \end{cscm}
	\item We need to change \vscm{make-save} to put the register name on the 
	    stack, and \vscm{make-restore} to check that the original register 
	    corresponds to the target register:
	    \scm{ch5/5.11b.scm}
	\item I chose to modify \vscm{make-register} to directly add a stack to 
	    each register:
	    \scm{ch5/5.11c.scm}
	    Some other procedures must be modified as well: no stack is needed 
	    anymore in
	    \linebreak
	    \vscm{make-new-machine}, and the \vscm{stack} parameter can be 
	    removed from
	    \linebreak
	    \vscm{make-execution-procedure}. As indicated in the text, the 
	    \vscm{initialize-stack} operation should initialize all the register 
	    stacks, which can be done by replacing the original definition of 
	    \vscm{the-ops} in \vscm{make-new-machine} with:
	    \scm{ch5/5.11c-init.scm}
    \end{enumerate}
\end{exe}

\begin{exe}[5.12]
    \label{5.12}
    Since we need ordered sets, we first reuse a slightly modified version of 
    the representation of sets as ordered lists defined in section~\ref{2.3.3}:
    \scm{ch5/5.12set.scm}
    To store the list of all instructions, we change \vscm{assemble} and 
    \vscm{extract-label} to build the list gradually as the instructions are 
    processed and then add it to the machine:
    \scm{ch5/5.12a1.scm}
    We also modify \vscm{make-new-machine} to define \vscm{instructions-list} as 
    the empty list at first and add new cases to the \vscm{dispatch} procedure:
    \scm{ch5/5.12a2.scm}
    To store the lists of the registers used to hold entry points and of the 
    registers that are \vscm{saved} or \vscm{restored}, we change 
    \vscm{make-new-machine} to define those lists, as well as procedures to add 
    an element to them and new messages to access them:
    \scm{ch5/5.12b2.scm}
    We then modify \vscm{make-goto}, \vscm{make-save} and \vscm{make-restore} to 
    add elements to the lists:
    \scm{ch5/5.12b1.scm}
    To store the sources from which each register is assigned, we change 
    \vscm{make-register} to store this information in each register, and 
    \vscm{make-assign} to add the sources to the target register. We also define 
    a \vscm{get-sources} procedure to access this information more easily:
    \scm{ch5/5.12c.scm}
\end{exe}

\begin{exe}[5.13]
    We change \vscm{make-machine} so it does not take a list of registers as an 
    argument:
    \scm{ch5/5.13a.scm}
    Then, we change the \vscm{lookup-register} procedure in 
    \vscm{make-new-machine} so that it allocates a new register if no register 
    with the given name exists. I also modified \vscm{allocate-register} to 
    return the newly allocated register to simplify the procedures. The dispatch 
    clause for \vscm{allocate-register} can be removed.
    \scm{ch5/5.13b.scm}
\end{exe}

\subsection{Monitoring Machine Performance}

\begin{exe}[5.14]
    The recursive factorial machine can be modified as shown below to initialize 
    the stack and print the statistics.
    \scm{ch5/5.14.scm}
    The total number of push operations and the maximum stack depth used in 
    computing $n!$ are both equal to $2 (n - 1)$: the \vscm{n} and 
    \vscm{continue} registers are each saved $n - 1$ times, then all the 
    elements of the stack are popped.
\end{exe}

\begin{exe}[5.15]
    We need to change \vscm{make-new-machine} at three places:
    \begin{enumerate}[label=\arabic*.]
	\item Add an \vscm{instruction-count} in the variables defined by the 
	    \vscm{let} at the beginning:
	    \begin{cscm}
		(instruction-count 0)
	    \end{cscm}

	\item Modify \vscm{execute} to increase the count before executing the 
	    procedure:
	    \scm{ch5/5.15a.scm}

	\item Add a message to the \vscm{dispatch} procedure to print and reset 
	    the count:
	    \scm{ch5/5.15b.scm}
    \end{enumerate}
\end{exe}

\begin{exe}[5.16]
    As in the previous exercise, the \vscm{make-new-machine} procedure must be 
    modified in three places:
    \begin{enumerate}[label=\arabic*.]
	\item Add a \vscm{trace} variable (initialized to \vscm{false}).
	\item Modify \vscm{execute} to display the instruction:
	    \scm{ch5/5.16a.scm}
	\item Add the messages \vscm{trace-on} and \vscm{trace-off} to the 
	    \vscm{dispatch} procedure:
	    \scm{ch5/5.16b.scm}
    \end{enumerate}
\end{exe}

\begin{exe}[5.17]
    \label{5.17}
    First, we change the representation of instructions from a pair to a list of 
    three elements: the instruction text, the label immediately preceding the 
    instruction, and the execution procedure.
    \scm{ch5/5.17a.scm}
    Then, we change \vscm{make-label-entry} so that it sets the label name of 
    the instruction following the label, if any:
    \scm{ch5/5.17b.scm}
    Lastly, we define a procedure to print an instruction and call it in 
    \vscm{execute}:
    \scm{ch5/5.17c.scm}
\end{exe}

\begin{exe}[5.18]
    We can modify the \vscm{make-register} procedure and define procedures to 
    turn tracing on and off for a given register as shown below. This extends 
    the definition of \vscm{make-register} from exercise~\ref{5.12}.
    \scm{ch5/5.18.scm}
\end{exe}

\begin{exe}[5.19]
    The procedures described in the text are just syntactic sugar:
    \scm{ch5/5.19a.scm}
    We will need the labels in order to find the instruction where to put the 
    breakpoint, so we add a message to set them to the machine and set them in 
    \vscm{assemble}:
    \scm{ch5/5.19b.scm}
    We add the appropriate messages to the \vscm{dispatch} procedure in 
    \vscm{make-new-machine}:
    \scm{ch5/5.19c.scm}
    A breakpoint is defined as a pair containing the label and offset, and the 
    representation of instructions from exercise~\ref{5.17} is extended to 
    include the breakpoint. We define procedures to check if an instruction has 
    a breakpoint and to remove the breakpoint from an instruction as well.
    \scm{ch5/5.19d.scm}
    The only missing part is the code actually handling the messages:
    \begin{itemize}
	\item To set or cancel a breakpoint, we look up the instruction 
	    corresponding to the given label and offset and add or remove the 
	    breakpoint to the instruction.
	\item To cancel all breakpoints, we remove any breakpoint from each 
	    instruction in the instruction sequence.
	\item The \vscm{execute} procedure is modified to check if the next 
	    instruction has a breakpoint. If so, it prints the information 
	    regarding the breakpoint and stops executing instructions.
	\item To continue execution, we just call \vscm{execute}, but we need to 
	    tell this procedure that it should not check again whether the next 
	    instruction is a breakpoint (we know it is and we already stopped), 
	    which we do with an additional parameter to \vscm{execute}, which is 
	    \vscm{false} only when proceeding from a breakpoint.
    \end{itemize}
    \scm{ch5/5.19e.scm}
\end{exe}

\section{Storage Allocation and Garbage Collection}

\subsection{Memory as Vectors}

\begin{exe}[5.20]
    The box-and-pointer representation and the memory-vector representation of 
    the given list structure are shown in figure~\ref{5.20y}. The final value of 
    \vscm{free} is \vscm{p4}. The values of \vscm{x} and \vscm{y} are 
    represented by the pointers \vscm{p1} and \vscm{p3} respectively.
    \begin{figure}
        \centering
	\begin{tikzpicture}[box and pointer]
	    % Box-and-pointer representation.
	    \matrix[cell matrix] (box-pointer) {
		\node[struct name] (y) {y}; &[+2\boxsize]
		\node[car, label=225:{3}] (c11) {}; & \node[cdr] (c12) {}; 
		&[+\boxsize]
		\node[car, label=225:{2}] (c13) {}; & \node[cdr] (c14) {}; \\

		\node[struct name] (x) {x}; &[+2\boxsize]
		\node[car, label=225:{1}] (c21) {}; & \node[cdr] (c22) {}; &
		\node[box] (n2) {2}; \\

		&
		\node[box] (n1) {1}; \\
	    };

	    \draw[pointer] (y) -- (c11);
	    \draw[pointer] (x) -- (c21);
            \link{c11}{c21}
            \link{c12}{c13}
	    \draw[box pointer] (c13.base) -- ++(0, -1cm) -| (c22);
	    \nil{c14}
	    \link{c21}{n1}
	    \link{c22}{n2}

	    % Memory-vector representation.
	    \node[right=of box-pointer] {
	    \renewcommand\arraystretch{1.5}
	    \newcommand\mc[1]{\multicolumn{1}{|c}{#1}}
	    \newcommand\emc{\mc{\hphantom{n1}}}
	    \setlength{\arrayrulewidth}{1pt}
	    \begin{tabular}{rcccccc}
		Index & 0 & 1 & 2 & 3 & 4 & ... \\\cline{2-7}
		the-cars & \emc & \mc{n1} & \mc{p1} & \mc{p1} & \emc & \mc{...} 
		\\\cline{2-7}
		the-cdrs & \emc & \mc{n2} & \mc{e0} & \mc{p2} & \emc & \mc{...} 
		\\\cline{2-7}
	    \end{tabular}
	    };
	\end{tikzpicture}
	\caption{The list structure produced by \vscm{(define x (cons 1 2))} 
	followed by \vscm{(define y (list x x))}.}
	\label{5.20y}
    \end{figure}
\end{exe}

\begin{exe}[5.21]
    \begin{enumerate}
	\item We can define a register machine to count the leaves of a tree as 
	    follows:
	    \scm{ch5/5.21a.scm}
	\item The register machine with an explicit counter can be defined as 
	    follows. This version is simpler because the second recursion can be 
	    transformed into a loop.
	    \scm{ch5/5.21b.scm}
    \end{enumerate}
\end{exe}

\begin{exe}[5.22]
    We can define the \vscm{append-machine} and \vscm{append!-machine} as 
    follows. The second version is simpler because there is a simple loop while 
    the first version uses recursion.
    \scm{ch5/5.22a.scm}
    \scm{ch5/5.22b.scm}
\end{exe}

\subsection{Maintaining the Illusion of Infinite Memory}

This subsection contains no exercises.

\section{The Explicit-Control Evaluator}

\subsection{The Core of the Explicit-Control Evaluator}

This subsection contains no exercises.

\subsection{Sequence Evaluation and Tail Recursion}

This subsection contains no exercises.

\subsection{Conditionals, Assignments, and Definitions}

\begin{exe}[5.23]
    I added the expressions \vscm{cond} (including the alternative syntax from 
    exercise~\ref{4.5}), \vscm{and} and \vscm{or} from exercise~\ref{4.4}, 
    \vscm{let} (\ref{4.6} and~\ref{4.8}), \vscm{let*} (\ref{4.7}), \vscm{letrec} 
    (\ref{4.20}), and \vscm{while}, \vscm{until} and \vscm{for} from 
    exercise~\ref{4.9}.

    The changes are similar for each expression type, so I am including them 
    here only for \vscm{cond} expressions. Besides loading the necessary syntax 
    predicates, selectors and transformers, we add a new test to the 
    \vscm{eval-dispatch} loop:
    \begin{cscm}
	(test (op cond?) (reg exp))
	(branch (label ev-cond))
    \end{cscm}
    At the given label, we transform the expression to evaluate before going 
    back to \vscm{eval-dispatch}:
    \begin{cscm}
    ev-cond
        (assign exp (op cond->if) (reg exp))
        (goto (label eval-dispatch))
    \end{cscm}
    It is tempting to go to \vscm{ev-if} instead, but if the \vscm{cond} 
    expression has no clauses, \vscm{cond->if} simply returns \vscm{false}, 
    which is not an \vscm{if} expression, so this would lead to an error. 
    Several other transformations (\vscm{and}, \vscm{or}, \vscm{let}...) also do 
    not always return an expression of the same type, so I chose to always 
    return to the \vscm{eval-dispatch} label after the transformation, even if 
    in some cases we could directly jump to the right expression type.
\end{exe}

\begin{exe}[5.24]
    We can implement \vscm{cond} as a new special form by replacing the 
    instructions handling such expressions with the instructions included below.

    The instructions are a translation of the \vscm{cond->if} procedure to 
    register-machine code.

    The loop starts at the label \vscm{ev-cond-clauses}, at which point the 
    \vscm{unev} register holds the remaining clauses. We first check if there 
    are remaining clauses. If no clauses remain, either because the \vscm{cond} 
    was empty or because no predicate was true, we return \vscm{false}. Then we 
    test whether the next clause is an \vscm{else} clause:
    \begin{itemize}
	\item If not, we evaluate the next clause’s predicate, after saving all 
	    the registers that could be needed later.
	    \begin{itemize}
		\item If the predicate is true, we evaluate the clause’s actions 
		    as a sequence. We save \vscm{continue} because it should be 
		    on the stack when reaching \vscm{ev-sequence}.
		\item If the predicate is false, we update \vscm{unev} to remove 
		    the first clause and go back to the beginning of the loop.
	    \end{itemize}
	\item If so, we check whether it is the last clause:
	    \begin{itemize}
		\item If not, we raise an error.
		\item If so, we evaluate the actions, as when a true predicate 
		    is found.
	    \end{itemize}
    \end{itemize}
    \scm{ch5/5.24b.scm}
\end{exe}

\begin{exe}[5.25]
    I used some procedures for thunk manipulation from section~\ref{lazy-eval} 
    as primitive procedures: \vscm{delay-it}, \vscm{thunk?}, \vscm{thunk-exp}, 
    \vscm{thunk-env}, \vscm{evaluated-thunk?} and \vscm{thunk-value}.

    The other changes to the evaluator described in that section are implemented 
    in the explicit-control evaluator: I modified \vscm{ev-application}, 
    \vscm{apply-dispatch}, \vscm{ev-if} and the driver loop. For this, the 
    equivalent of \vscm{actual-value} in the explicit-control evaluator is 
    needed.

    The \vscm{actual-value} procedure from section~\ref{lazy-eval} just calls 
    \vscm{force-it} on the result of \vscm{eval}, so in the register machine, it 
    saves the \vscm{continue} register and goes to \vscm{force-it} at the end of 
    \vscm{eval-dispatch}. At the \vscm{force-it} label, the \vscm{continue} 
    register is restored, then the actual value of the contents of the 
    \vscm{val} register is computed, and if \vscm{val} contained a thunk it is 
    turned into an evaluated thunk.
    \begin{cscm}
    actual-value
        (save continue)
        (assign continue (label force-it))
        (goto (label eval-dispatch))
    force-it
        ;; Forces value of reg val.
        ; Saved at actual-value
        (restore continue)
        (test (op thunk?) (reg val))
        (branch (label force-thunk))
        (test (op evaluated-thunk?) (reg val))
        (branch (label force-evaluated-thunk))
        (goto (reg continue))
    force-thunk
        (assign env (op thunk-env) (reg val))
        (assign exp (op thunk-exp) (reg val))
        ; Comment out the following 3 lines to use unmemoized force-it.
        (save val) ; Save thunk to set its value later.
        (save continue)
        (assign continue (label thunk-result-forced))
        (goto (label actual-value))
    thunk-result-forced
        ; val contains the actual value.
        (assign exp (reg val))
        (restore continue)
        (restore val) ; Thunk
        (perform (op set-car!) (reg val) (const evaluated-thunk))
        (assign unev (op cdr) (reg val))
        (perform (op set-car!) (reg unev) (reg exp))
        (perform (op set-cdr!) (reg unev) (const ()))
        (assign val (reg exp))
        (goto (reg continue))
    force-evaluated-thunk
        (assign val (op thunk-value) (reg val))
        (goto (reg continue)))))
    \end{cscm}
    The above instructions implement the memoized version of \vscm{force-it}. To 
    use the non-memoized version, it is enough to comment out the lines that set 
    up the stack and the continuation so that the thunk is turned into an 
    evaluated thunk once its value has been computed: that way the 
    \vscm{thunk-result-forced} label is never reached, so no evaluated thunks 
    are created.

    With these instructions for \vscm{actual-value}, the only change needed at 
    the places where \vscm{actual-value} is used in the lazy evaluator is to 
    replace \vscm{(goto (label eval-dispatch))} with
    \vscm{(goto (label actual-value))}, which is the only change needed in 
    \vscm{read-eval-print-loop} and in \vscm{ev-if}.

    Significant changes to \vscm{ev-application} and \vscm{apply-dispatch} are 
    needed. The instructions at \vscm{ev-application} are simplified since the 
    argument accumulation is now left to \vscm{apply-dispatch}. The actual value 
    of the operator is computed and stored in \vscm{proc}, the operand 
    expressions are put in \vscm{unev}, and the rest is left to 
    \vscm{apply-dispatch}:
    \begin{cscm}
    ev-application
        (save continue)
        (save env)
        (assign unev (op operands) (reg exp))
        (save unev)
        (assign exp (op operator) (reg exp))
        (assign continue (label ev-appl-did-operator))
        (goto (label actual-value))
    ev-appl-did-operator
        (restore unev)          ; the operands
        (restore env)
        (assign proc (reg val)) ; the operator
        (goto (label apply-dispatch))
    \end{cscm}

    The beginning of \vscm{apply-dispatch} does not change much: it dispatches 
    on the procedure type. It also initializes the argument list.
    \begin{cscm}
    apply-dispatch
        ; Actual value of procedure to apply in proc, operand expressions in 
        ; unev, environment in env.
        (assign argl (op empty-arglist))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-apply))
        (test (op compound-procedure?) (reg proc))
        (branch (label compound-apply))
        (goto (label unknown-procedure-type))
    \end{cscm}

    Before applying a primitive procedure, the actual values of the arguments 
    must be computed and accumulated in \vscm{argl}, which was previously done 
    in \vscm{ev-application}. The instructions are almost the same as those used 
    in \vscm{ev-application} in the applicative-order evaluator, the main 
    difference is the use of \vscm{actual-value} rather than 
    \vscm{eval-dispatch} to compute each argument value.
    \begin{cscm}
    primitive-apply
        ; Accumulate actual values of arguments in argl.
        (save proc)
        (test (op no-operands?) (reg unev))
        (branch (label actual-primitive-apply))
    ev-appl-operand-loop
        (save argl)
        (assign exp (op first-operand) (reg unev))
        (test (op last-operand?) (reg unev))
        (branch (label ev-appl-last-arg))
        (save env)
        (save unev)
        (assign continue (label ev-appl-accumulate-arg))
        (goto (label actual-value))
    ev-appl-accumulate-arg
        (restore unev)
        (restore env)
        (restore argl)
        (assign argl (op adjoin-arg) (reg val) (reg argl))
        (assign unev (op rest-operands) (reg unev))
        (goto (label ev-appl-operand-loop))
    ev-appl-last-arg
        (assign continue (label ev-appl-accum-last-arg))
        (goto (label actual-value))
    ev-appl-accum-last-arg
        (restore argl)
        (assign argl (op adjoin-arg) (reg val) (reg argl))
    actual-primitive-apply
        (restore proc)
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (restore continue)
        (goto (reg continue))
    \end{cscm}

    Before applying a compound procedure, the delayed arguments are accumulated. 
    Though the procedures \vscm{list-of-arg-values} and 
    \vscm{list-of-delayed-args} are very similar in section~\ref{lazy-eval}, 
    their register-machine translations are very different: for the latter no 
    actual computation besides the argument accumulation is done so we can use 
    a simple loop without using the stack at all, unlike the implementation of 
    \vscm{list-of-arg-values} above.
    \begin{cscm}
    compound-apply
        ; Accumulate delayed arguments in argl.
        (test (op no-operands?) (reg unev))
        (branch (label actual-compound-apply))
        (assign exp (op first-operand) (reg unev))
        (assign exp (op delay-it) (reg exp) (reg env))
        (assign argl (op adjoin-arg) (reg exp) (reg argl))
        (assign unev (op rest-operands) (reg unev))
        (goto (label compound-apply))
    actual-compound-apply
        (assign unev (op procedure-parameters) (reg proc))
        (assign env (op procedure-environment) (reg proc))
        (assign env (op extend-environment) (reg unev) (reg argl) (reg env))
        (assign unev (op procedure-body) (reg proc))
        (goto (label ev-sequence))
    \end{cscm}
\end{exe}

\subsection{Running the Evaluator}

\begin{exe}[5.26]
    \ \vspace{-20pt}
    \begin{enumerate}
	\item The maximum depth is 10 for $n \geq 1$. For $n = 0$ the maximum 
	depth is 8.

    \item The number of pushes for any $n \geq 0$ is equal to $35n + 29$.
    \end{enumerate}
\end{exe}

\begin{exe}[5.27]
    The results found are, for any $n \geq 1$:
    \begin{center}
	\begin{tabular}{|c|c|c|}
	    \hline
	    & Maximum depth & Number of pushes \\\hline
	    Recursive factorial & $5n + 3$ & $32n - 16$ \\\hline
	    Iterative factorial & $10$ & $35n + 29$ \\\hline
	\end{tabular}
    \end{center}
\end{exe}

\begin{exe}[5.28]
    With a non tail-recursive evaluator, both procedures now require space and 
    time that grow linearly with their input. The results can be summed up in 
    the following table, for any $n \geq 1$:
    \begin{center}
	\begin{tabular}{|c|c|c|}
	    \hline
	    & Maximum depth & Number of pushes \\\hline
	    Recursive factorial & $8n + 3$ & $34n - 16$ \\\hline
	    Iterative factorial & $3n + 14$ & $37n + 33$ \\\hline
	\end{tabular}
    \end{center}
\end{exe}
